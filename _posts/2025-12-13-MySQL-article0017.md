---
layout:     page
title:      "Innodb的Redo Log"
subtitle:   "《MySql是怎么样运行的》笔记：Innodb的Redo Log"
date:       2025-12-13
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
    - 笔记
---


# 概述
为了效率InnoDB创建了Buffer Pool建立内存和硬盘之间的映射，当出现脏页时也不马上刷新到硬盘中而是堆积起来等到合适的机会在一个批次的一起刷新到磁盘中，这样就出现了一段内存与磁盘数据不一致的时期，而内存数据是暂时，当断电了之后数据就会丢失，所以在这个时期当出现系统崩溃的时候就可能导致这段时间的修改都丢失了，违背了持久性。

为了解决上述问题，InnoDB设置了redo日志：将对页面的修改情况都按照特定格式记录在特定的文件中，在事务提交时保证其落盘到文件中，当出现崩溃则可以通过redo日志进行还原。

之所以使用redo日志而不直接落盘是因为redo日志落盘是数据年比页面的16k页面**占用空间小的多**，并且落盘redo日志为**顺序写入**所以会比flush链表落盘随机写入快很多。

所以采用了一个代价更小的措施做副本，来保证最终结果。

# redo日志格式

redo日志本质上只是记录了一下事务对数据库做了哪些修改。 InnoDB的对事务对数据库的不同修改场景定义了多种类型的redo日志，通用的结构：

![image-20251213132022040]({{site.baseurl}}/img/in-post/article0017/image-20251213132022040.png)

- type：该条redo日志的类型。
- space ID：表空间ID。
- page number：页号。
- data：该条redo日志的具体内容。

## 简单的redo日志类型

redo日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，InnoDB把这种简单的redo日志称之为物理日志：

- MLOG_1BYTE（type对应1）：表示在页面的某个偏移量处写入1个字节的redo日志类型。
- MLOG_2BYTE（type对应2）：表示在页面的某个偏移量处写入2个字节的redo日志类型。
- MLOG_4BYTE（type对应4）：表示在页面的某个偏移量处写入4个字节的redo日志类型。
- MLOG_8BYTE（type对应8）：表示在页面的某个偏移量处写入8个字节的redo日志类型。
- MLOG_WRITE_STRING（type对应30）：表示在页面的某个偏移量处写入一串数据。

![image-20251213132347627]({{site.baseurl}}/img/in-post/article0017/image-20251213132347627.png)

![image-20251213132431894]({{site.baseurl}}/img/in-post/article0017/image-20251213132431894.png)

## 复杂一些的redo日志类型

在一条sql语句的修改通过会修改一个页面中的很多地方，如insert就可能修改Page Directory中的槽信息, Page Header的统计信息，甚至可能导致页分裂。

所以InnoDb设置一些redo日志类型：

- MLOG_REC_INSERT（type对应9）：表示插入一条使用非紧凑行格式的记录时的redo日志类型。
- MLOG_COMP_REC_INSERT（type对应38）：表示插入一条使用紧凑行格式的记录时的redo日志类型。
- MLOG_COMP_PAGE_CREATE（type对应58）：表示创建一个存储紧凑行格式记录的页面的redo日志类型。
- MLOG_COMP_REC_DELETE（type对应42）：表示删除一条使用紧凑行格式记录的redo日志类型。
- MLOG_COMP_LIST_START_DELETE（type对应44）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的redo日志类型。
- MLOG_COMP_LIST_END_DELETE（type对应43）：与MLOG_COMP_LIST_START_DELETE类型的redo日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE类型的redo日志对应的记录为止。

这些类型的redo日志既包含物理层面的意思，也包含逻辑层面的意思，具体指：
- 物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。
- 逻辑层面看，在系统奔溃重启时，不能根据日志直接还原，而是**需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子**。

# Mini-Transaction

## 以组的形式写入redo日志

在执行一条语句的过程中可能修改若干个页面，对应若干条redo日志，当崩溃发生时，这些redo日志就应该以一组的形式一起执行还原，或者一起不执行还原，不能一部执行了还原一部不执行, 例如：
- 向聚簇索引对应B+树的页面中插入一条记录时产生的redo日志是不可分割的。
- 向某个二级索引对应B+树的页面中插入一条记录时产生的redo日志是不可分割的。


所以在执行**这些需要保证原子性的操作时必须以组的形式来记录的redo日志**，在进行系统奔溃重启恢复时，针对某个组中的redo日志，要么把全部的日志都恢复掉，要么一条也不恢复。

- 对于一组中多条redo日志的原子性保障通过设置**该组中的最后一条redo日志后边加上一条特殊类型的redo日志（类型为MLOG_MULTI_REC_END （31））**

![image-20251213134354931]({{site.baseurl}}/img/in-post/article0017/image-20251213134354931.png)

所以某个需要保证原子性的操作产生的一系列redo日志必须要以一个类型为MLOG_MULTI_REC_END结尾，就像这样：

![image-20251213134405053]({{site.baseurl}}/img/in-post/article0017/image-20251213134405053.png)

**在系统奔溃重启进行恢复时，只有当解析到类型为MLOG_MULTI_REC_END的redo日志，才认为解析到了一组完整的redo日志，才会进行恢复。否则的话直接放弃前面解析到的redo日志**。

- 对于只有一条redo日志的原子性，为了节省空间，通过type的最高是否为1来判断。

![image-20251213134548813]({{site.baseurl}}/img/in-post/article0017/image-20251213134548813.png)

## Mini-Transaction的概念

MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction，简称mtr。一个mtr可以包含一组redo日志，在进行奔溃恢复时这一组redo日志作为一个不可分割的整体。

一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志：

![image-20251213134943433]({{site.baseurl}}/img/in-post/article0017/image-20251213134943433.png)

# redo日志的写入过程

InnoDB为了更好的进行系统奔溃恢复，把通过mtr生成的redo日志都放在了**大小为512字节的页（机械磁盘原子写入为512字节）中**。这里把用来存储redo日志的页称为block。一个redo log block的示意图如下：

![image-20251213135857372]({{site.baseurl}}/img/in-post/article0017/image-20251213135857372.png)

## log block header

![image-20251213135923168]({{site.baseurl}}/img/in-post/article0017/image-20251213135923168.png)

- LOG_BLOCK_HDR_NO：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。
- LOG_BLOCK_HDR_DATA_LEN：表示block中已经使用了多少字节，初始值为12（因为log block body从第12个字节处开始）。
- LOG_BLOCK_FIRST_REC_GROUP：这个block里第一个mtr生成的第一条redo日志的偏移量。
- LOG_BLOCK_CHECKPOINT_NO：表示所谓的checkpoint的序号。

### LOG_BLOCK_HDR_NO
这个属性是初次使用该block时分配的，跟当时的系统lsn值有关。：
> ((lsn / 512) & 0x3FFFFFFFUL) + 1

不论lsn多大，((lsn / 512) & 0x3FFFFFFFUL)的值肯定在0~0x3FFFFFFFUL之间，再加1的话肯定在1~0x40000000UL(1GB)之间。最多能产生不重复的LOG_BLOCK_HDR_NO值只有1GB个。

InnoDB规定redo日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。

LOG_BLOCK_HDR_NO值的第一个比特位比较特殊，称之为flush bit。

```
// LOG_BLOCK_HDR_NO 的32位结构
// 31              0  (位位置)
// [F][Block Number...] (F=flush bit)

// 实际存储示例
uint32_t LOG_BLOCK_HDR_NO = 0x80000001;  // 二进制: 1000 0000 0000 0000 0000 0000 0000 0001
                                          // ↑最高位=1表示flush bit置位
                                          // 实际block编号 = 0x00000001
```
**当flush bit被设置为1时，表示在write这个log block的时候，必须执行fsync操作。**

触发条件：事务提交（某些设置下）、log buffer满、checkpoint等

## redo日志缓冲区


同 Buffer Pool，写入redo日志时也不直接直接写到磁盘上，服务器启动时申请了一大片的连续内存空间，即redo log buffer（redo日志缓冲区）。

![image-20251213140307649]({{site.baseurl}}/img/in-post/article0017/image-20251213140307649.png)

通过启动参数innodb_log_buffer_size来指定log buffer的大小，在MySQL 5.7.21这个版本中，该启动参数的默认值为16MB。


## redo日志写入log buffer

向log buffer中写入redo日志的过程是顺序的。通过buf_free的全局变量，指向log buffer中空闲位置的起点，如图所示：

![image-20251213140704716]({{site.baseurl}}/img/in-post/article0017/image-20251213140704716.png)

写入log buffer时不是以单条记录为单位，而是一组mtr的记录为单位，**所以每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，再将这一组redo日志再全部复制到log buffer中**。

不同的事务可能是并发执行的，所以T1、T2之间的mtr可能是交替执行的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的：

![image-20251213141032275]({{site.baseurl}}/img/in-post/article0017/image-20251213141032275.png)

# redo落盘
## redo日志刷盘时机

在一些情况下它们会被刷新到磁盘里，

- log buffer空间不足时
 > log buffer的大小是有限的。log buffer总容量使用了大约一半左右，就需要把这些日志刷新到磁盘上。

- 事务提交时
> 为了保证持久性，必须要把修改这些页面对应的redo日志刷新到磁盘。

- 后台线程定时刷新
> 后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。

- 正常关闭服务器时
- 做所谓的checkpoint时
- 其他的一些情况...

## redo日志文件组

redo日志落盘的文件在MySQL的数据目录中（使用SHOW VARIABLES LIKE 'datadir'查看） ，默认有两个名为ib_logfile0和ib_logfile1的文件。

可以通过参数进行调节：

- innodb_log_group_home_dir
> 指定了redo日志文件所在的目录，默认值就是当前的数据目录。

- innodb_log_file_size
> 指定了每个redo日志文件的大小，在MySQL 5.7.21这个版本中的默认值为48MB，

- innodb_log_files_in_group
> 数指定redo日志文件的个数，默认值为2，最大值为100。

磁盘上的redo日志文件不只一个，而是以一个日志文件组，并且将日志文件组组成一个环形数组的形式使用。

## redo日志文件格式

在log buffer是一连串的512字节大小的block组成的，那么redo日志也是由一连串的512字节大小的block组成的。

redo日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：

- 前2048个字节，也就是前4个block是用来存储一些管理信息的。
- 从第2048字节往后是用来存储log buffer中的block镜像的。

![image-20251213145726521]({{site.baseurl}}/img/in-post/article0017/image-20251213145726521.png)

普通的block格式与log buffer中的一致。

redo日志文件中的前4个block格式如下：

![image-20251213145827084]({{site.baseurl}}/img/in-post/article0017/image-20251213145827084.png)



- log file header：描述该redo日志文件的一些整体属性，看一下它的结构：

![image-20251213145917920]({{site.baseurl}}/img/in-post/article0017/image-20251213145917920.png)

| 属性名               | 长度（字节） | 描述                                                         |
| -------------------- | ------------ | ------------------------------------------------------------ |
| LOG_HEADER_FORMAT    | 4            | redo日志的版本，在MySQL 5.7.21中该值永远为1                  |
| LOG_HEADER_PAD1      | 4            | 做字节填充用的                                               |
| LOG_HEADER_START_LSN | 8            | 标记本redo日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值 |
| LOG_HEADER_CREATOR   | 32           | 一个字符串，标记本redo日志文件的创建者是谁。                 |
| LOG_BLOCK_CHECKSUM   | 4            | 本block的校验值                                              |

- checkpoint1：记录关于checkpoint的一些属性，看一下它的结构：

![image-20251213150151818]({{site.baseurl}}/img/in-post/article0017/image-20251213150151818-1765631486602-1.png)

| 属性名                      | 长度（字节） | 描述                                                         |
| --------------------------- | ------------ | ------------------------------------------------------------ |
| LOG_CHECKPOINT_NO           | 8            | 服务器做checkpoint的编号，每做一次checkpoint，该值就加1。    |
| LOG_CHECKPOINT_LSN          | 8            | 服务器做checkpoint结束时对应的LSN值，系统奔溃恢复时将从该值开始。 |
| LOG_CHECKPOINT_OFFSET       | 8            | 上个属性中的LSN值在redo日志文件组中的偏移量                  |
| LOG_CHECKPOINT_LOG_BUF_SIZE | 8            | 服务器在做checkpoint操作时对应的log buffer的大小             |
| LOG_BLOCK_CHECKSUM          | 4            | 本block的校验值                                              |

- 第三个block未使用
- checkpoint2：结构和checkpoint1一样。

## Log Sequeue Number

InnoDB为记录已经写入的redo日志量，设计了一个称之为Log Sequeue Number的全局变量：即日志序列号，简称lsn。

InnoDB规定lsn的初始值为8704，每增加一组redo日志，lsn就会增加该组redo日志的字节数，如果有跨log block还会增加log block header和log block trailer的字节数，即有点像是系统写入的redo日志量的一个总和。

每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。


### flushed_to_disk_lsn

redo日志是首先写到log buffer中，之后才会被刷新到磁盘上的redo日志文件。

所以InnoDB提出了一个称为buf_next_to_write的全局变量，表示当前log buffer中已经有哪些日志执行write操作。

同时InnoDB提出了一个称为flushed_to_disk_lsn的全局变量，表示当前log buffer中哪些日志已经明确刷新到磁盘中（fsync函数）。

![image-20251213211801264]({{site.baseurl}}/img/in-post/article0017/image-20251213211801264.png)

操作系统中write操作只是将数据存入系统缓存中，需要将数据写入到磁盘中还需执行fsync函数才能明确。

可以通过 innodb_flush_log_at_trx_commit 系统变量控制执行 fsync函数的策略。

- 0：表示在事务提交时不会执行write操作也不会执行fsync操作，这个任务是交给后台线程做的。
- 1：表示在事务提交时需要将redo日志同步到磁盘，可以保证事务的持久性。该值也是默认值。
- 2：表示在事务提交时需要将redo日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。


### flush链表中的LSN

在mtr结束时，会把这一组redo日志写入到log buffer中。**还会把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表**。

当第一次修改某个缓存在Buffer Pool中的页面时，就会把这个页面对应的控制块插入到flush链表的头部，之后再修改该页面时由于它已经在flush链表中了，就不再次插入了。**也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的**。

在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：
- oldest_modification：如果某个页面被加载到Buffer Pool后进行第一次修改，那么就将修改该页面的**mtr开始时**对应的lsn值写入这个属性，用于计算checkpoint_lsn值。
- newest_modification：每修改一次页面，都会将修改该页面的mtr结束时对应的lsn值写入这个属性。


**flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值**。


## checkpoint

因为redo日志文件组是作为一个环形数组使用的，所以为了保证环形数组的可用性，当Buffer Pool中的脏页已经持久化到磁盘中，那么其对应redo日志也就无用了可以覆盖了。

InnoDB提出了一个全局变量checkpoint_lsn来代表当前系统中可以被覆盖的redo日志总量是多少，这个变量初始值也是8704。

当脏页被刷新到了磁盘，对应redo日志就可以被覆盖了，所以可以进行一个增加checkpoint_lsn的操作，我们把这个过程称之为做一次checkpoint。

做一次checkpoint其实可以分为两个步骤：
1. 计算一下当前系统中可以被覆盖的redo日志对应的lsn值最大是多少。
> redo日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要flush链表队尾的脏页对应的oldest_modification值（写入redo前的lsn值），那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的oldest_modification赋值给checkpoint_lsn。
2. 将checkpoint_lsn和对应的redo日志文件组偏移量以及此次checkpint的编号写到日志文件的管理信息（就是checkpoint1或者checkpoint2）中
> InnoDB维护了一个目前系统做了多少次checkpoint的变量checkpoint_no，每做一次checkpoint，该变量的值就加1。

## 查看系统中的各种LSN值

我们可以使用SHOW ENGINE INNODB STATUS命令查看当前InnoDB存储引擎中的各种LSN值的情况，比如：
```
mysql> SHOW ENGINE INNODB STATUS\G

(...省略前面的许多状态)
LOG
---
Log sequence number 124476971
Log flushed up to   124099769
Pages flushed up to 124052503
Last checkpoint at  124052494
0 pending log flushes, 0 pending chkp writes
24 log i/o's done, 2.00 log i/o's/second
----------------------
```

- Log sequence number：代表系统中的lsn值，也就是当前系统已经写入的redo日志量，包括写入log buffer中的日志。
- Log flushed up to：代表flushed_to_disk_lsn的值，也就是当前系统已经写入磁盘的redo日志量。
- Pages flushed up to：代表flush链表中被最早修改的那个页面对应的oldest_modification属性值。
- Last checkpoint at：当前系统的checkpoint_lsn值。

# 崩溃恢复

## 确定恢复的起点

对于checkpoint_lsn之后的redo日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，所以需要从checkpoint_lsn开始读取redo日志来恢复页面。

通过对比两个checkpoint中的checkpoint_no大小，得到最新的checkpoint，进而得到对应的checkpoint_lsn值以及它在redo日志文件组中的偏移量checkpoint_offset。

## 确定恢复的终点
普通block的log block header部分有一个称之为LOG_BLOCK_HDR_DATA_LEN的属性，该属性值记录了当前block里使用了多少字节的空间。

对于被填满的block来说，该值永远为512。如果该属性的值不为512，那么就是它了，它就是此次奔溃恢复中需要扫描的最后一个block。

## 怎么恢复
redo日志可能会有很多，一组日志一组日志的恢复效率不高，所以有使用了一些措施加快恢复过程：


- 使用哈希表
> 将 space ID和page number进行归类，将同一个页面的redo日志一起恢复，减少随机IO。需注意redo的时间顺序。

- 跳过已经刷新到磁盘的页面

> 在每个页面中File Header里有一个FIL_PAGE_LSN的属性，记载了最近一次修改页面时对应的lsn值（即页面控制块中的newest_modification值）。已经在磁盘中的页面读取出该值说明小于该lsn的redo日志已经无效了。 



