---
layout:     page
title:      "lambda表达式的实现原理"
subtitle:   "以字节码实现的角度来分析lambda表达式的实现原理。"
date:       2025-12-02
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - JDK
---

# 概述

以字节码实现的角度来分析lambda表达式的实现原理。

# 实验环境

实验代码如下：
```
public class TestMain {
    public static void main(String[] var0) {
        Runnable runnable1 = () -> System.out.println("-----1-----");
        Runnable runnable2 = () -> System.out.println("-----2-----");

        System.out.println(runnable1.getClass().getName());
        System.out.println(runnable2.getClass().getName());

        runnable1.run();
        runnable2.run();
    }
}
```

将实验代码的class通过**javap -c -p -l -v TestMain**进行反编译：
```
Classfile /F:/temp/TestMain.class
  Last modified 2025▒▒8▒▒25▒▒; size 1294 bytes
  SHA-256 checksum 077f613fdba0f4dd4888b9e6fb8d36ab34eed5814cab939b289d2af5ccfbd66b
  Compiled from "TestMain.java"
public class TestMain
  minor version: 0
  major version: 65
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #43                         // TestMain
  super_class: #2                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 4, attributes: 3
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
   #2 = Class              #4             // java/lang/Object
   #3 = NameAndType        #5:#6          // "<init>":()V
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = InvokeDynamic      #0:#8          // #0:run:()Ljava/lang/Runnable;
   #8 = NameAndType        #9:#10         // run:()Ljava/lang/Runnable;
   #9 = Utf8               run
  #10 = Utf8               ()Ljava/lang/Runnable;
  #11 = InvokeDynamic      #1:#8          // #1:run:()Ljava/lang/Runnable;
  #12 = Fieldref           #13.#14        // java/lang/System.out:Ljava/io/PrintStream;
  #13 = Class              #15            // java/lang/System
  #14 = NameAndType        #16:#17        // out:Ljava/io/PrintStream;
  #15 = Utf8               java/lang/System
  #16 = Utf8               out
  #17 = Utf8               Ljava/io/PrintStream;
  #18 = InterfaceMethodref #19.#20        // java/lang/Runnable.getClass:()Ljava/lang/Class;
  #19 = Class              #21            // java/lang/Runnable
  #20 = NameAndType        #22:#23        // getClass:()Ljava/lang/Class;
  #21 = Utf8               java/lang/Runnable
  #22 = Utf8               getClass
  #23 = Utf8               ()Ljava/lang/Class;
  #24 = Methodref          #25.#26        // java/lang/Class.getName:()Ljava/lang/String;
  #25 = Class              #27            // java/lang/Class
  #26 = NameAndType        #28:#29        // getName:()Ljava/lang/String;
  #27 = Utf8               java/lang/Class
  #28 = Utf8               getName
  #29 = Utf8               ()Ljava/lang/String;
  #30 = Methodref          #31.#32        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #31 = Class              #33            // java/io/PrintStream
  #32 = NameAndType        #34:#35        // println:(Ljava/lang/String;)V
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               println
  #35 = Utf8               (Ljava/lang/String;)V
  #36 = InterfaceMethodref #19.#20        // java/lang/Runnable.getClass:()Ljava/lang/Class;
  #37 = InterfaceMethodref #19.#38        // java/lang/Runnable.run:()V
  #38 = NameAndType        #9:#6          // run:()V
  #39 = String             #40            // -----2-----
  #40 = Utf8               -----2-----
  #41 = String             #42            // -----1-----
  #42 = Utf8               -----1-----
  #43 = Class              #44            // TestMain
  #44 = Utf8               TestMain
  #45 = Utf8               Code
  #46 = Utf8               LineNumberTable
  #47 = Utf8               main
  #48 = Utf8               ([Ljava/lang/String;)V
  #49 = Utf8               lambda$main$1
  #50 = Utf8               lambda$main$0
  #51 = Utf8               SourceFile
  #52 = Utf8               TestMain.java
  #53 = Utf8               BootstrapMethods
  #54 = MethodType         #6             //  ()V
  #55 = MethodHandle       6:#56          // REF_invokeStatic TestMain.lambda$main$0:()V
  #56 = Methodref          #43.#57        // TestMain.lambda$main$0:()V
  #57 = NameAndType        #50:#6         // lambda$main$0:()V
  #58 = MethodHandle       6:#59          // REF_invokeStatic TestMain.lambda$main$1:()V
  #59 = Methodref          #43.#60        // TestMain.lambda$main$1:()V
  #60 = NameAndType        #49:#6         // lambda$main$1:()V
  #61 = MethodHandle       6:#62          // REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #62 = Methodref          #63.#64        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #63 = Class              #65            // java/lang/invoke/LambdaMetafactory
  #64 = NameAndType        #66:#67        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #65 = Utf8               java/lang/invoke/LambdaMetafactory
  #66 = Utf8               metafactory
  #67 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
  #68 = Utf8               InnerClasses
  #69 = Class              #70            // java/lang/invoke/MethodHandles$Lookup
  #70 = Utf8               java/lang/invoke/MethodHandles$Lookup
  #71 = Class              #72            // java/lang/invoke/MethodHandles
  #72 = Utf8               java/lang/invoke/MethodHandles
  #73 = Utf8               Lookup
{
  public TestMain();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: invokedynamic #7,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;
         5: astore_1
         6: invokedynamic #11,  0             // InvokeDynamic #1:run:()Ljava/lang/Runnable;
        11: astore_2
        12: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;
        15: aload_1
        16: invokeinterface #18,  1           // InterfaceMethod java/lang/Runnable.getClass:()Ljava/lang/Class;
        21: invokevirtual #24                 // Method java/lang/Class.getName:()Ljava/lang/String;
        24: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        27: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;
        30: aload_2
        31: invokeinterface #36,  1           // InterfaceMethod java/lang/Runnable.getClass:()Ljava/lang/Class;
        36: invokevirtual #24                 // Method java/lang/Class.getName:()Ljava/lang/String;
        39: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        42: aload_1
        43: invokeinterface #37,  1           // InterfaceMethod java/lang/Runnable.run:()V
        48: aload_2
        49: invokeinterface #37,  1           // InterfaceMethod java/lang/Runnable.run:()V
        54: return
      LineNumberTable:
        line 3: 0
        line 4: 6
        line 6: 12
        line 7: 27
        line 9: 42
        line 10: 48
        line 11: 54

  private static void lambda$main$1();
    descriptor: ()V
    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=2, locals=0, args_size=0
         0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #39                 // String -----2-----
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 4: 0

  private static void lambda$main$0();
    descriptor: ()V
    flags: (0x100a) ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
    Code:
      stack=2, locals=0, args_size=0
         0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #41                 // String -----1-----
         5: invokevirtual #30                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 3: 0
}
SourceFile: "TestMain.java"
BootstrapMethods:
  0: #61 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #54 ()V
      #55 REF_invokeStatic TestMain.lambda$main$0:()V
      #54 ()V
  1: #61 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #54 ()V
      #58 REF_invokeStatic TestMain.lambda$main$1:()V
      #54 ()V
InnerClasses:
  public static final #73= #69 of #71;    // Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles
```

# 字节码分析
在 main方法体中的第0行和第5行的字节码中使用了 invokedynamic 指令，来动态的创建lambda表达式。

## invokedynamic说明

> invokedynamic 是Java 7 引入的字节码指令，用于支持 动态语言和Lambda表达式的实现。它将方法调用点抽象为 CallSite 对象，并由应用程序提供的引导方法（Bootstrap Method）在运行时获取要调用的实际方法的句柄。


invokedynamic 指令在运行时将方法调用绑定到方法句柄，而 CallSite 就是这个绑定过程的产物，它封装了实际要调用的方法句柄（MethodHandle），使得方法调用可以在运行时被动态地重定向。﻿

提供动态绑定的灵活性：
CallSite 可以是常量性的（ConstantCallSite）、可变的（MutableCallSite）或易变的（VolatileCallSite），允许在运行时改变方法的绑定目标。﻿

invokedynamic 和CallSite 的工作流程：
1. 遇到 invokedynamic 指令：JVM 在执行字节码时，遇到一条 invokedynamic 指令。﻿
2. 调用引导方法（Bootstrap Method）：JVM 调用该指令关联的引导方法（Bootstrap Method）。﻿
3. 生成CallSite：引导方法会执行一系列操作，最终返回一个 CallSite 实例。﻿
4. 获取方法句柄：通过 CallSite 的 getTarget() 方法，可以获取到实际要调用的目标方法句柄。﻿
5. 方法调用：后续对该 invokedynamic 指令的调用，就等同于调用这个 CallSite 所绑定的方法句柄。﻿





## invokedynamic实现
>  invokedynamic #7,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;

从字节码中可以看出 invokedynamic 命令后面跟随的是 #7 这个常量。

>    #7 = InvokeDynamic      #0:#8          // #0:run:()Ljava/lang/Runnable;      
>    #8 = NameAndType        #9:#10         // run:()Ljava/lang/Runnable;

在常量池中可以找到 #7 的值，中引用了#0:#8，#8表示的是#8号常量, 但是#0 就很奇怪了，因为常量池中的索引是从1开始的，并没有 #0 常量，所以 InvokeDynamic 所使用的 第一个参数（#0） 并不是常量池中的内容，而是使用的 BootstrapMethods （BSM）中的内容。

```
  0: #61 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #54 ()V
      #55 REF_invokeStatic TestMain.lambda$main$0:()V
      #54 ()V
```

在 BootstrapMethods 中的可以看出通过 REF_invokeStatic 关联调用静态方法 java/lang/invoke/LambdaMetafactory.metafactory 获取相关方法的句柄。


## LambdaMetafactory
在 java.lang.invoke.LambdaMetafactory#metafactory 方法：
```java
public static CallSite metafactory(MethodHandles.Lookup caller,
                                   String interfaceMethodName,
                                   MethodType factoryType,
                                   MethodType interfaceMethodType,
                                   MethodHandle implementation,
                                   MethodType dynamicMethodType) {
    AbstractValidatingLambdaMetafactory mf;
    mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),
                                         Objects.requireNonNull(factoryType),
                                         Objects.requireNonNull(interfaceMethodName),
                                         Objects.requireNonNull(interfaceMethodType),
                                         Objects.requireNonNull(implementation),
                                         Objects.requireNonNull(dynamicMethodType),
                                         false,
                                         EMPTY_CLASS_ARRAY,
                                         EMPTY_MT_ARRAY);
    mf.validateMetafactoryArgs();
    return mf.buildCallSite();
}
```

在 InnerClassLambdaMetafactory 中
```java
CallSite buildCallSite() throws LambdaConversionException {
    final Class<?> innerClass = spinInnerClass();
    if (invokedType.parameterCount() == 0) {
        Object inst = ctrs[0].newInstance();
        return new ConstantCallSite(MethodHandles.constant(samBase, inst));
    } else {
        UNSAFE.ensureClassInitialized(innerClass);
        return new ConstantCallSite(
                    MethodHandles.Lookup.IMPL_LOOKUP
                         .findStatic(innerClass, NAME_FACTORY, invokedType));
    }
}
private Class<?> spinInnerClass() throws LambdaConversionException {
    // 通过 ASM ClassWriter 构建 lambda 字节码
    cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
             lambdaClassName, null, JAVA_LANG_OBJECT, interfaces);
    cw.visitEnd();

    // lambda表达式类字节码数组
    final byte[] classBytes = cw.toByteArray(); 

    // 提交给JVM加载成class对象
    return UNSAFE.defineAnonymousClass(targetClass, classBytes, null);
}
```

这样在指令 invokedynamic 执行之后就会获取到一个 持有对应lambda表达式的方法句柄的CallSite。

## BootstrapMethods 中的Method arguments

在 LambdaMetafactory.metafactory 方法中，前三个参数为jvm自行传递， 最后三个参数是来自 BSM 的附加静态参数即 BootstrapMethods 中的Method arguments 中的。

## LambdaMetafactory.altMetafactory 方法
当 lambda 表达式实现了 Serializable 接口，在编译class文件中对应lambda表达式中的 BSM中使用的就是 java/lang/invoke/LambdaMetafactory.altMetafactory 方法了。

没有Serializable接口则使用 java/lang/invoke/LambdaMetafactory.metafactory

lambda有实现了 Serializable 接口，在lambda的类结构中会增加一个 writeReplace 方法，调用 SerializedLambda 类。 当lambda中捕获到的参数没有实现 Serializable接口时就会报错（NotSerializableException）

参考： https://www.zhihu.com/question/51491241/answer/126232275


# lambda类结构
对lambda字节码进行导出反编译得到：

## 未捕获参数
在lambda表达式中没有任何的自由变量（free variable），不需要从外围环境中捕获任何变量。这种lambda也叫做non-capturing lambda。

```java
// Runnable runnable2 = () -> System.out.println("-----2-----");

final class TestMain$$Lambda$1 implements Runnable {
    static final long serialVersionUID = -5573715425150064196L;

    private TestMain$$Lambda$1() {
    }

    @Hidden
    public void run() {
        TestMain.lambda$main$0();
    }
}
```

## 捕获参数

在lambda表达式中有从外围环境中捕获任何变量。这种lambda也叫做capturing lambda。

```java
// PrintStream out = System.out;
// Runnable runnable1 = () -> out.println("-----1-----");

final class TestMain$$Lambda$1 implements Runnable {
    private final PrintStream arg$1;
    static final long serialVersionUID = 6201180887455682281L;

    private TestMain$$Lambda$1(PrintStream var1) {
        this.arg$1 = var1;
    }

    private static Runnable get$Lambda(PrintStream var0) {
        return new TestMain$$Lambda$1(var0);
    }

    @Hidden
    public void run() {
        TestMain.lambda$main$0(this.arg$1);
    }
}
```

```
private static void lambda$main$0(java.io.PrintStream);
  descriptor: (Ljava/io/PrintStream;)V
  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC
  Code:
    stack=2, locals=1, args_size=1
        0: aload_0
        1: ldc           #10                 // String -----1-----
        3: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        6: return

BootstrapMethods:
  0: #38 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #39 ()V
      #40 invokestatic com/bonree/test/TestMain.lambda$main$0:(Ljava/io/PrintStream;)V
      #39 ()V
```


# 参考资料
https://blogs.oracle.com/javamagazine/post/behind-the-scenes-how-do-lambda-expressions-really-work-in-java

https://zhuanlan.zhihu.com/p/360224441

https://zhuanlan.zhihu.com/p/350884967