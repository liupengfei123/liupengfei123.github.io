---
layout:     page
title:      "Innodb的Undo Log"
subtitle:   "《MySql是怎么样运行的》笔记：Innodb的Undo Log"
date:       2025-12-14
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
    - 笔记
---

# 概述
事务需要保证原子性，即事务中的操作要么全部完成，要么什么也不做。当事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。

当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要 把回滚时所需的东西都给记下来。这些为了回滚而记录称之为撤销日志，英文名为undo log（undo日志）。

# 事务ID

## 事务分配ID的时机

一个事务可以是一个只读事务，或者是一个读写事务：

- 通过START TRANSACTION READ ONLY语句开启一个只读事务。
> 在只读事务中不可以对普通的表进行增、删、改操作，但可以对**临时表**做增、删、改操作。

- 通过START TRANSACTION READ WRITE语句开启一个读写事务，或者使用BEGIN、START TRANSACTION语句开启的事务默认也是读写事务。
> 在读写事务中可以对表执行增删改查操作。

如果某个事务执行过程中对**某个表(包括用户创建的临时表)**执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id。

## 事务ID生成规则

事务id就是一个递增数字, 具体策略如下：

- 服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id时，就会把该变量的值当作事务id分配给该事务，并且把该变量自增1。
- 每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为5的页面中一个称之为Max Trx ID的属性处，这个属性占用8个字节的存储空间。
- 当系统下一次重新启动时，会将上面提到的Max Trx ID属性加载到内存中，**将该值加上256之后赋值给我们前面提到的全局变量**（因为在上次关机时该全局变量的值可能大于Max Trx ID属性值）。

这样就可以保证整个系统中分配的事务id值是一个递增的数字。先被分配id的事务得到的是较小的事务id，后被分配id的事务得到的是较大的事务id。

## trx_id，roll_pointer隐藏列

在InnoDB记录行格式中聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列。
- trx_id列就是当前记录修改对应事务ID。
- roll_pointer指向记录的undo日志的指针，用于MVCC。

![image-20251214105607938]({{site.baseurl}}/img/in-post/article0018/image-20251214105607938.png)

![image-20251214111734827]({{site.baseurl}}/img/in-post/article0018/image-20251214111734827-1765682255737-1.png)

# undo日志的格式

为了事务的原子性，InnoDB在实际进行增、删、改一条记录时，都需要先把对应的undo日志记下来。

一般每对一条记录做一次改动，就对应着一条undo日志，但在某些更新记录的操作中，也可能会对应着2条undo日志。

一个事务在执行过程中可能新增、删除、更新若干条记录，会有需要记录很多条对应的undo日志，这些undo日志会被从0开始编号，即第0号undo日志、第1号undo日志、...、第n号undo日志等，该编号叫做undo no。

这些undo日志被记录到类型为FIL_PAGE_UNDO_LOG（十六进制是0x0002）的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放undo日志的表空间，即undo tablespace中。


PS：因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚undo日志时，在回滚聚簇索引记录时，可以将所有二级索引中相应的记录也回滚了。**所以undo日志也都是针对聚簇索引记录而言的**。

## INSERT操作对应的undo日志

当回滚插入操作，那么把这条记录删除就好了，即在写对应的undo日志时，主要是把这条记录的主键信息记上。InnoDB设计了一个类型为TRX_UNDO_INSERT_REC的undo日志：

![image-20251214110338476]({{site.baseurl}}/img/in-post/article0018/image-20251214110338476.png)

- undo no在**一个事务中是从0开始递增的**，即只要事务没提交，每生成一条undo日志，那么该条日志的undo no就增1。
- 如果记录中的主键不管时单列还是多列，每个列占用的存储空间大小和对应的真实值都需要记录下来。
- 因为insert时创建新记录所以没有roll_point。

## DELETE操作对应的undo日志

使用DELETE语句删除过程经历两个阶段：

- 阶段一：仅仅将记录的delete_mask标识位设置为1，其他的不做修改（其实会修改记录的trx_id、roll_pointer这些隐藏列的值）。这个阶段称之为delete mark。

![image-20251214130006656]({{site.baseurl}}/img/in-post/article0018/image-20251214130006656.png)

- 阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。设计InnoDB的大佬把这个阶段称之为purge。

![image-20251214125955229]({{site.baseurl}}/img/in-post/article0018/image-20251214125955229.png)

在删除语句所在的事务提交之前，只会经历阶段一，也就是delete mark阶段。InnoDB为此设计了一种称之为TRX_UNDO_DEL_MARK_REC类型的undo日志。

![image-20251214130148253]({{site.baseurl}}/img/in-post/article0018/image-20251214130148253.png)

- 在对一条记录进行delete mark操作前，需要把该记录的旧的trx_id和roll_pointer隐藏列的值都给记到对应的undo日志中。可以形成一个MVCC链表

![image-20251214130310712]({{site.baseurl}}/img/in-post/article0018/image-20251214130310712.png)

- 还多了一个索引列各列信息的内容。索引列各列信息存储的内容实质上就是<pos, len, value>的一个列表。主要是用在事务提交后，对该中间状态记录做真正删除的阶段二，也就是purge阶段中使用的。 如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个索引列各列信息部分，所谓的相关信息包括该列在记录中的位置（用pos表示），该列占用的存储空间大小（用len表示），该列实际值（用value表示）。

## UPDATE操作对应的undo日志

在执行UPDATE语句时，InnoDB对更新主键和不更新主键这两种情况有截然不同的处理方案。

### 不更新主键的情况
又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。

#### 就地更新（in-place update）
更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的**列占用的存储空间都一样大（大了小了都不行）**，那么就可以进行就地更新，也就是直接在原记录的基础上修改对应列的值。

#### 先删除掉旧记录，再插入新记录
如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。

这里所说的删除并不是delete mark操作，而是真正的删除掉，即把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息。不过这里做真正删除操作的线程由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。

针对UPDATE不更新主键的情况（包括上面所说的就地更新和先删除旧记录再插入新记录），InnoDB设计了一种类型为TRX_UNDO_UPD_EXIST_REC的undo日志

![image-20251214131254358]({{site.baseurl}}/img/in-post/article0018/image-20251214131254358.png)

- n_updated属性表示本条UPDATE语句执行后将有几个列被更新，后边跟着的<pos, old_len, old_value>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。
- 如果在UPDATE语句中更新的列包含索引列，那么也会添加索引列各列信息这个部分，否则的话是不会添加这个部分的。


### 更新主键的情况

针对UPDATE语句中更新了记录主键值的这种情况，InnoDB在聚簇索引中分了两步处理：

- 将旧记录进行delete mark操作
- 根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中。

所以针对UPDATE语句更新记录主键值的这种情况，在对该记录进行delete mark操作前，会记录一条类型为TRX_UNDO_DEL_MARK_REC的undo日志；之后插入新记录时，会记录一条类型为TRX_UNDO_INSERT_REC的undo日志，也就是说每对一条记录的主键值做改动时，会记录2条undo日志。

# Undo页面
## FIL_PAGE_UNDO_LOG页面结构

为FIL_PAGE_UNDO_LOG类型的页面是专门用来存储undo日志，这里简称Undo页面。

![image-20251214132159891]({{site.baseurl}}/img/in-post/article0018/image-20251214132159891.png)

![image-20251214132239469]({{site.baseurl}}/img/in-post/article0018/image-20251214132239469.png)

- TRX_UNDO_PAGE_TYPE：本页面准备存储什么种类的undo日志。
    - TRX_UNDO_INSERT（使用1表示）：类型为TRX_UNDO_INSERT_REC的undo日志属于此大类，一般由INSERT语句产生，或者在UPDATE语句中有更新主键的情况也会产生此类型的undo日志。
    - TRX_UNDO_UPDATE（使用2表示），除了类型为TRX_UNDO_INSERT_REC的undo日志，其他类型的undo日志都属于这个大类，如TRX_UNDO_DEL_MARK_REC、TRX_UNDO_UPD_EXIST_REC的，一般由DELETE、UPDATE语句产生的undo日志属于这个大类。
    - 这个TRX_UNDO_PAGE_TYPE属性可选的值就是上面的两个，用来标记本页面用于存储哪个大类的undo日志，不同大类的undo日志不能混着存储。
> ps: 之所以把undo日志分成两个大类，是因为类型为TRX_UNDO_INSERT_REC的undo日志在事务提交后可以直接删除掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删除掉，对它们的处理需要区别对待。

- TRX_UNDO_PAGE_START：表示在当前页面中是从什么位置开始存储undo日志的，或者说表示第一条undo日志在本页面中的起始偏移量。
- TRX_UNDO_PAGE_FREE：与上面的TRX_UNDO_PAGE_START对应，表示当前页面中存储的最后一条undo日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的undo日志。
- TRX_UNDO_PAGE_NODE：代表一个List Node结构。

## Undo页面链表

### 单个事务中的Undo页面链表

因为一个事务可能包含多个语句，而且一个语句可能对若干条记录进行改动，而对每条记录进行改动前，都需要记录1条或2条的undo日志，所以在一个事务产生的undo日志会存放在多个undo页中。

![image-20251214132934274]({{site.baseurl}}/img/in-post/article0018/image-20251214132934274.png)

链表中的第一个Undo页面，称它为first undo page，其余的Undo页面称之为normal undo page，在first undo page中除了记录Undo Page Header之外，还会记录其他的一些管理信息。

在一个事务执行过程中，可能混着执行INSERT、DELETE、UPDATE语句，也就意味着会产生不同类型的undo日志。所以在一个事务执行过程中就可能需要2个Undo页面的链表，一个称之为insert undo链表，另一个称之为update undo链表：

![image-20251214133143077]({{site.baseurl}}/img/in-post/article0018/image-20251214133143077.png)

InnoDB规定对普通表和临时表的记录改动时产生的undo日志要分别记录，所以在一个事务中最多有4个以Undo页面为节点组成的链表：

![image-20251214202004888]({{site.baseurl}}/img/in-post/article0018/image-20251214202004888.png)

并不是在事务一开始就会为这个事务分配这4个链表，具体分配按需分配，什么时候需要什么时候再分配，不需要就不分配。

### 多个事务中的Undo页面链表

为了尽可能提高undo日志的写入效率，不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中。

比方说现在有事务id分别为1、2的两个事务，我们分别称之为trx 1和trx 2，假设在这两个事务执行过程中：

- trx 1对普通表做了DELETE操作，对临时表做了INSERT和UPDATE操作。InnoDB会为trx 1分配3个链表，分别是：
  - 针对普通表的update undo链表
  - 针对临时表的insert undo链表
  - 针对临时表的update undo链表。

- trx 2对普通表做了INSERT、UPDATE和DELETE操作，没有对临时表做改动。InnoDB会为trx 2分配2个链表，分别是：
  - 针对普通表的insert undo链表
  - 针对普通表的update undo链表。

![image-20251214133424787]({{site.baseurl}}/img/in-post/article0018/image-20251214133424787.png)

## undo日志具体写入过程

### Undo Log Segment Header

InnoDB规定，**每一个Undo页面链表都对应着一个段，称之为Undo Log Segment，即链表中的页面都是从这个段里边申请的**，所以他们在Undo页面链表的第一个页面，也就是上面提到的first undo page中设计了一个称之为Undo Log Segment Header的部分，所以**Undo页面链表的第一个页面**其实长这样：

![image-20251214133748681]({{site.baseurl}}/img/in-post/article0018/image-20251214133748681.png)

可以看到这个Undo链表的第一个页面比普通页面多了个Undo Log Segment Header：

![image-20251214133759087]({{site.baseurl}}/img/in-post/article0018/image-20251214133759087.png)

- TRX_UNDO_STATE：本Undo页面链表处在什么状态。
    - TRX_UNDO_ACTIVE：活跃状态，也就是一个活跃的事务正在往这个段里边写入undo日志。
    - TRX_UNDO_CACHED：被缓存的状态。处在该状态的Undo页面链表等待着之后被其他事务重用。
    - TRX_UNDO_TO_FREE：对于insert undo链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
    - TRX_UNDO_TO_PURGE：对于update undo链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。
    - TRX_UNDO_PREPARED：包含处于PREPARE阶段(分布式事务)的事务产生的undo日志。
- TRX_UNDO_LAST_LOG：本Undo页面链表中最后一个Undo Log Header的位置(重用undo页面)。
- TRX_UNDO_FSEG_HEADER：本Undo页面链表对应的段的Segment Header信息。
- TRX_UNDO_PAGE_LIST：Undo页面链表的基节点。

### Undo Log Header
一个事务在向Undo页面中写入undo日志时的方式是十分简单暴力的，就是直接往里怼，写完一条紧接着写另一条，各条undo日志之间是亲密无间的。写完一个Undo页面后，再从段里申请一个新页面，然后把这个页面插入到Undo页面链表中，继续往这个新申请的页面中写。

InnoDB认为同一个事务向一个Undo页面链表中写入的undo日志算是一个组，比方说我们上面介绍的trx 1由于会分配3个Undo页面链表，也就会写入3个组的undo日志；trx 2由于会分配2个Undo页面链表，也就会写入2个组的undo日志。

在每写入一组undo日志时，都会在这组undo日志前先记录一下关于这个组的一些属性，设计InnoDB的大佬把存储这些属性的地方称之为Undo Log Header。所以Undo页面链表的第一个页面在真正写入undo日志前，其实都会被填充Undo Page Header、Undo Log Segment Header、Undo Log Header这3个部分，如图所示：

![image-20251214134614635]({{site.baseurl}}/img/in-post/article0018/image-20251214134614635.png)

![image-20251214134629545]({{site.baseurl}}/img/in-post/article0018/image-20251214134629545.png)

- TRX_UNDO_TRX_ID：生成本组undo日志的事务id。
- TRX_UNDO_TRX_NO：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。
- TRX_UNDO_DEL_MARKS：标记本组undo日志中是否包含由于Delete mark操作产生的undo日志。
- TRX_UNDO_LOG_START：表示本组undo日志中第一条undo日志的在页面中的偏移量。
- TRX_UNDO_XID_EXISTS：本组undo日志是否包含XID信息。
- TRX_UNDO_DICT_TRANS：标记本组undo日志是不是由DDL语句产生的。
- TRX_UNDO_TABLE_ID：如果TRX_UNDO_DICT_TRANS为真，那么本属性表示DDL语句操作的表的table id。
- TRX_UNDO_NEXT_LOG：下一组的undo日志在页面中开始的偏移量。
- TRX_UNDO_PREV_LOG：上一组的undo日志在页面中开始的偏移量。
- TRX_UNDO_HISTORY_NODE：一个12字节的List Node结构，代表一个称之为History链表的节点。

### 小结

对于没有被重用的Undo页面链表来说，链表的第一个页面，也就是first undo page在真正写入undo日志前，会填充Undo Page Header、Undo Log Segment Header、Undo Log Header这3个部分，之后才开始正式写入undo日志。对于其他的页面来说，也就是normal undo page在真正写入undo日志前，只会填充Undo Page Header。 

链表的List Base Node存放到first undo page的Undo Log Segment Header部分，List Node信息存放到每一个Undo页面的undo Page Header部分

![image-20251214134900769]({{site.baseurl}}/img/in-post/article0018/image-20251214134900769.png)

## 重用Undo页面
为了能提高并发执行的多个事务写入undo日志的性能，InnoDB决定为每个事务单独分配相应的Undo页面链表。但是这样也造成了一些问题，如绝大部分事务只有一点点undo日志，undo页面也就只存储了一点点存储，但是用了一个链表存储就造就了资源的浪费。

InnoDB决定在事务提交后在某些情况下重用该事务的Undo页面链表。一个Undo页面链表是否可以被重用需要同时满足以下两点：
- 该链表中只包含一个Undo页面。
- 该Undo页面已经使用的空间小于整个页面空间的3/4。


在重用insert undo链表和update undo链表的策略也不同：
- insert undo链表

> insert undo链表中只存储类型为TRX_UNDO_INSERT_REC的undo日志，这种类型的undo日志在事务提交之后就没用了，就可以被清除掉。所以重用这个事务的insert undo链表时，可以直接把之前事务写入的一组undo日志覆盖掉：

![image-20251214140504947]({{site.baseurl}}/img/in-post/article0018/image-20251214140504947.png)

- update undo链表

> 在一个事务提交后，它的update undo链表中的undo日志也不能立即删除掉（用于MVCC）。所以如果之后的事务想重用update undo链表时，就不能覆盖之前事务写入的undo日志。这样就相当于在同一个Undo页面中写入了多组的undo日志：

![image-20251214140622743]({{site.baseurl}}/img/in-post/article0018/image-20251214140622743.png)

# 回滚段
## 回滚段的概念
InnoDB设计了一个称之为Rollback Segment Header的页面，在这个页面中存放了各个Undo页面链表的frist undo page的页号，他们把这些页号称之为undo slot。

![image-20251214140916685]({{site.baseurl}}/img/in-post/article0018/image-20251214140916685.png)

InnoDB规定，每一个Rollback Segment Header页面都对应着一个段，这个段就称为Rollback Segment（回滚段）。
与之前介绍的各种段不同的是，这个Rollback Segment里其实只有一个页面。

- TRX_RSEG_MAX_SIZE：本Rollback Segment中管理的所有Undo页面链表中的Undo页面数量之和的最大值。
- TRX_RSEG_HISTORY_SIZE：History链表占用的页面数量。
- TRX_RSEG_HISTORY：History链表的基节点。
- TRX_RSEG_FSEG_HEADER：本Rollback Segment对应的10字节大小的Segment Header结构，通过它可以找到本段对应的INODE Entry。
- TRX_RSEG_UNDO_SLOTS：各个Undo页面链表的first undo page的页号集合，也就是undo slot集合。

## 从回滚段中申请Undo页面链表

初始情况下在一个Rollback Segment Header页面来说，它的各个undo slot都被设置成了一个特殊的值：FIL_NULL（对应的十六进制就是0xFFFFFFFF），表示该undo slot不指向任何页面。

随着时间的流逝，开始有事务需要分配Undo页面链表了，就从回滚段的第一个undo slot开始，看看该undo slot的值是不是FIL_NULL：

- 如果是FIL_NULL，然后从段里申请一个页面作为Undo页面链表的first undo page，然后把该undo slot的值设置为刚刚申请的这个页面的地址，即这个undo slot被分配给了这个事务。
- 如果不是FIL_NULL，说明该undo slot已经被别的事务占用了，那就跳到下一个undo slot，判断该undo slot的值是不是FIL_NULL，重复上面的步骤。

一个Rollback Segment Header页面中包含1024个undo slot，如果这1024个undo slot的值都不为FIL_NULL，这就意味着这1024个undo slot都被分配给了事务，此时由于新事务无法再获得新的Undo页面链表，就会回滚这个事务并且给用户报错：

> Too many active concurrent transactions


当一个事务提交时，它所占用的undo slot有两种命运：

- 如果该undo slot指向的Undo页面链表符合被重用的条件: 
  该undo slot就处于被缓存的状态，InnoDB规定这时该Undo页面链表的TRX_UNDO_STATE属性会被设置为TRX_UNDO_CACHED。
    - Undo页面链表是insert undo链表，则该undo slot会被加入insert undo cached链表。
    - Undo页面链表是update undo链表，则该undo slot会被加入update undo cached链表。
  

一个回滚段就对应着上述两个cached链表(在存储结构中没有映射到页面中持久化，在启动时通过遍历undo slot的状态重建)，**如果有新事务要分配undo slot时，先从对应的cached链表中找。如果没有被缓存的undo slot，才会到回滚段的Rollback Segment Header页面中再去找**。

- 如果该undo slot指向的Undo页面链表不符合被重用的条件：
    - Undo页面链表是insert undo链表，则该Undo页面链表的TRX_UNDO_STATE属性会被设置为TRX_UNDO_TO_FREE，之后该Undo页面链表对应的段会被释放掉，然后把该undo slot的值设置为FIL_NULL。
    - Undo页面链表是update undo链表，则该Undo页面链表的TRX_UNDO_STATE属性会被设置为TRX_UNDO_TO_PRUGE，则会将该undo slot的值设置为FIL_NULL，然后将本次事务写入的一组undo日志放到所谓的History链表中。

## 多个回滚段

因为一个回滚段里只有1024个undo slot，即使假设一个读写事务执行过程中只分配1个Undo页面链表，那1024个undo slot也只能支持1024个读写事务同时执行，再多了就崩溃了。

所以InnoDB定义了128个回滚段，也就相当于有了128 × 1024 = 131072个undo slot。每个回滚段都对应着一个Rollback Segment Header页面，有128个回滚段，InnoDB在系统表空间的第5号页面的某个区域包含了128个8字节大小的格子：

![image-20251214143820822]({{site.baseurl}}/img/in-post/article0018/image-20251214143820822.png)

每个8字节的格子的构造就像这样：

![image-20251214143829002]({{site.baseurl}}/img/in-post/article0018/image-20251214143829002.png)

- 4字节大小的Space ID，代表一个表空间的ID。
- 4字节大小的Page number，代表一个页号。

要定位一个Rollback Segment Header还需要知道对应的表空间ID，这也就意味着不同的回滚段可能分布在不同的表空间中。

![image-20251214143920167]({{site.baseurl}}/img/in-post/article0018/image-20251214143920167.png)

## 回滚段的分类
这128个回滚段，最开始的回滚段称之为第0号回滚段，之后依次递增，最后一个回滚段就称之为第127号回滚段。

这128个回滚段可以被分成两大类：

- 第0号、第33～127号回滚段属于一类。其中第0号回滚段必须在系统表空间中，第33～127号回滚段既可以在系统表空间中，也可以在自己配置的undo表空间中。
    - 如果一个事务在执行过程中由于对普通表的记录做了改动需要分配Undo页面链表时，必须从这一类的段中分配相应的undo slot。

- 第1～32号回滚段属于一类。这些回滚段必须在临时表空间（对应着数据目录中的ibtmp1文件）中。
    - 如果一个事务在执行过程中由于对临时表的记录做了改动需要分配Undo页面链表时，必须从这一类的段中分配相应的undo slot。

如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段，再分别到这两个回滚段中分配对应的undo slot。


Undo页面其实是类型为FIL_PAGE_UNDO_LOG的页面的简称，说到底它也是一个普通的页面。**在修改页面之前一定要先把对应的redo日志写上，这样在系统奔溃重启时才能恢复到奔溃前的状态。**


在修改针对普通表的回滚段中的Undo页面时，需要记录对应的**redo日志**，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。

## undo日志写入Undo页面链表详细过程


每个事务最多可以有4个Undo页面链表，而且是在需要使用时才进行分配，分配过程如下以普通页为例：

- 事务先到系统表空间的第5号页面中分配一个回滚段（使用的round-robin循环分配方式来分配回滚段）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就直接使用该回滚段了。
- 在分配到回滚段后
    - 先判断该回滚段的两个cached链表（insert，update）有没有已经缓存了的undo slot，如果有缓存的undo slot，那么就把这个缓存的undo slot分配给该事务，即将undo页面链表从cached链表中删除，并更改将undo页面链表的first undo page相关数据，并且将其页号保存到事务中。
    - 如果没有缓存的undo slot可供分配，那么就要到Rollback Segment Header页面中找一个可用的undo slot分配给当前事务。新建一个Undo Log Segment，然后从该Undo Log Segment（段）中申请一个页面作为Undo页面链表的first undo page，将其页号写入undo slot中和保存到事务中。

当有了对应的undo页面链表时，就可以通过事务结构中链表的first undo page的页号，获取到undo页面链表，就可以往该链表中写入undo日志。


## 回滚段相关配置
### 配置回滚段数量
系统中默认有128个回滚段，可以通过启动参数innodb_rollback_segments来配置回滚段的数量，可配置的范围是1~128。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表的回滚段数量一直是32：
- 如果我们把innodb_rollback_segments的值设置为1，那么只会有1个针对普通表的可用回滚段，但是仍然有32个针对临时表的可用回滚段。
- 如果我们把innodb_rollback_segments的值设置为2～33之间的数，效果和将其设置为1是一样的。
- 如果我们把innodb_rollback_segments设置为大于33的数，那么针对普通表的可用回滚段数量就是该值减去32。


### 配置undo表空间
默认情况下，针对普通表设立的回滚段（第0号以及第33~127号回滚段）都是被分配到系统表空间的。其中的第0号回滚段是一直在系统表空间的，但是第33~127号回滚段可以通过配置放到自定义的undo表空间中。**但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了**。

- 通过innodb_undo_directory指定undo表空间所在的目录，如果没有指定该参数，则默认undo表空间所在的目录就是数据目录。
- 通过innodb_undo_tablespaces定义undo表空间的数量。该参数的默认值为0，表明不创建任何undo表空间。

第33~127号回滚段可以平均分布到不同的undo表空间中。

设立undo表空间的一个好处就是在undo表空间中的文件大到一定程度时，可以自动的将该undo表空间截断（truncate）成一个小文件。而系统表空间的大小只能不断的增大，却不能截断。

# undo日志在崩溃恢复时的作用
当那些没有提交的事务写的redo日志落盘了，那么这些未被提交的事务修改的页面在MySQL重启时可能被恢复了，为了保证事务的原子性，有必要在服务器重启时将未提交的事务回滚掉。

通过找到undo日志链表中的第一个页面的Undo Segment Header中的TRX_UNDO_STATE属性，如果时活跃状态的说明还在写undo日志，再通过Undo Segment Header中TRX_UNDO_LAST_LOG属性（重用页面所以找最后的），找到最后的Undo Log Header的位置，就能找到对应的事务ID。


# undo日志清理（Purge）

undo日志是有存储在表空间中的，也随之表空间持久化到对应的磁盘中的，为了使磁盘不会持续性的增大，就需要将无用的undo日志给清理掉。

前面有说过了,insert undo日志在事务提交之后就无用了，update undo日志在事务提交之后为了支持MVCC所以还不能清理，有将该链表设置到了回滚段的History链表中。

在合适的时候吧update undo日志和仅仅被标记为删除的记录彻底删除掉，这个操作称之为purge。

为了判断undo日志哪些可以被清理，InnoDB增加了一些数据：
- 在**事务提交时**,为该事务生成一个事务no的值（递增值，先提交的事务，事务no值小），并且会将事务no存储到undo log header中的 TRX_UNDO_TRX_NO中，回滚段中的History链表也是按照事务no顺序存储。
- 在ReadView中还有一个事务no的属性，在生成ReadView时，取当前系统最大的事务no值加一。

当后台线程触发Purge时，就会取出系统中最早生成的ReadView，然后和各个回滚段中的history链表对比，事务no值，如果undo日志的事务no比较小，那么说明该组undo日志已经没有了，就可以清理该undo链表。


# 总结

为了保证事务的原子性，InnoDB设计了undo日志，用于记载回滚一个操作所需的必要内容。

在事务对表中记录进行改动时，才会为这个事务分配一个唯一的事务ID（全局递增生成）。为被分配的事务ID的事务的事务ID值默认为0。聚簇索引记录中有一个trx_id隐藏列，表示对这个聚簇索引记录进行改动的语句所在事务对应的事务ID。

InnoDB对不同场景设计了不同类型的undo日志。

类型为FIL_PAGE_UNDO_LOG页面是专门用来存储undo日志的，这里简称undo页面。

一个事务执行过程中，最多分配4个undo页面链表（在有使用到时才创建）：
- 对普通表的insert undo链表
- 对普通表的update undo链表
- 对临时表的insert undo链表
- 对临时表的update undo链表

每个Undo页面链表都对应一个 Undo Log Segment(段)。链表中的页面都是在自身对应的Undo Log Segment(段)中创建的，Undo页面链表的第一个页面中有一个名为 Undo Log Segment Header的部分，用来存储关于该段的部分信息。

同一个事务像一个undo页面链表写入的undo日志算时一个组，每个组都以一个Undo Log Header 部分开头。

一个Undo页面链表如果可以被重用，需要符合两点条件：
- 该链表中只有一个Undo页面
- 该Undo页面已经使用空间小于整体页面空间的3/4。

每个一个Rollback Segment Header 页面都对应着一个回滚段，每个回滚段包含 1024个undo slot，一个undo slot代表一个Undo页面链表的第一个页面的页号。目前InnoDB最多支持128个回滚段，其中第0号、第33~127号回滚段时针对于普通表设计的，第1~32号回滚段是针对于临时表设计的。