---
layout:     page
title:      "Redis命令请求处理流程"
subtitle:   "《Redis设计与实现》笔记：命令请求处理流程"
date:       2025-12-06
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - Redis
    - 笔记
---

# 总体流程
一个命令请求从发送到收到回复的过程中，客户端和服务器需要完成一系列的操作。如set命令
```
redis> SET KEY VALUE
ok
```

在从客户端发送命令到获得OK期间，客户端和服务器的执行过程：
1. 客户端向服务器发送命令请求SET KEY VALUE。
2. 服务器接收并处理命令请求，在数据库中设置操作，并产生命令回复OK。
3. 服务器将OK发送给客户端。
4. 客户端接收服务器返回的命令OK，并打印给用户。


# 发送命令请求

![image](https://note.youdao.com/yws/res/17936/07DDAC96012B48B79C92A62EC70596E0)

用户：键入命令请求

客户端：将命令请求转换为协议格式然后发送给服务器

用户输入命令： 
> SET KEY VALUE

客户端会将命令转换成协议
> *3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n

# 读取命令请求
当连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器(readQueryFromClient)执行以下操作：

1. 读取套接字协议格式中的命令请求，并将其保存在客户端状态的输入缓冲区里。
2. 对输入缓冲区的命令请求进行分析，提取命令参数及其个数，保存到客户端状态的argv和argc属性  (processInputBuffer -> processInlineBuffer)。
3. 调用命令执行器，执行指定的命令(processInputBuffer -> processCommand)。

![image](https://note.youdao.com/yws/res/17961/81FA3B7CA5844E099BD2F74D79B951A1)

## 命令执行器（1）：查找命令实现
命令执行器要做的第一件事是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数指定的命令（通过 redis.c 的 lookupCommand方法），并将其保存到客户端状态的cmd属性里。

![image](https://note.youdao.com/yws/res/17971/5C8C8684079D4A44AEBDCDA03D78E534)


## 命令执行器（2）：执行预备操作
有了执行命令所需的命令实现函数、参数、参数个数，但程序还需要一些预备操作（在redis.c 的processCommand方法中）：

- 检查客户端状态的cmd指针是否为NULL。
- 根据cmd属性指向redisCommand结构的arity属性，检查命令请求的参数个数是否正确。
- 检查客户端是否通过了身份验证，未通过必须使用AUTH命令。
- 如果服务器打开了maxmemory功能，检查内存占用情况，有需要时进行内存回收。
- 如果上一次BGSAVE出错，且服务器打开了stop-writes-on-bgsave-error功能，且服务器要执行一个写命令，拒绝执行。
- 如果客户端正在用SUBSCRIBE订阅频道，服务器只会执行订阅相关的命令。
- 如果服务器正在进行输入载入，那么客户端发送的命令必须带有1标识才能被执行。
- 如果服务器因为Lua脚本而超时阻塞，那么服务器只会执行客户端发来的SHUTDOWN nosave和SCRIPT KILL命令。
- 如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、 DISCARD、 MULTI、 WATCH命令，其余命令进入事务队列。
- 如果服务器打开监视器功能，要将执行的命令和参数等信息发给监视器，其后才真正执行命令。

## 命令执行器（3）：调用命令的实现函数
在 redis.c 的 call 方法中，调用实际命令实现函数

> client -> cmd -> proc(client);

相当于执行语句：

> sendCommand(client);


命令回复会保存在输出缓冲区(addReply)，之后实现函数还会为套接字关联命令回复处理器(prepareClientToWrite)，将回复返回给客户端。

## 命令执行器（4）：执行后续工作
- 如果开启了慢查询，添加新的日志。
- redisCommand结构的calls计数器+1。
- 写入AOF缓冲区。
- 同步从服务器。



# 将命令回复发送给客户端
当客户端套接字变为可写时，服务器将输出缓冲区的命令发送给客户端。发送完毕后，清空输出缓冲区，并取消关联命令回复处理器。

# 客户端接收并打印命令回复

服务器：回复处理器将协议格式的命令返回给客户端。

客户端：将回复格式化成人类可读的格式，打印。



# 定义

## 命令表
命令表是一个字典，键是命令名字，值是一个redisCommand结构。命令表使用的是大小写无关的查找算法。

在redic.c文件中定义并初始化： 

![image](https://note.youdao.com/yws/res/17967/16AD9C592E5A4BA59B54B8B2A6337D46)

## redisCommandProc定义与实现

redisCommandProc 的方法定义在 redis.h 文件中：

![image](https://note.youdao.com/yws/res/17991/9F4BC92F263B4D0E8FC02F581BC9F551)

而其实现分布在各个.c 文件中如 redis.c, t_hash.c, t_set.c, t_string.c, t_list.c 等文件中。

```c
// redis.c 文件中
void authCommand(redisClient *c) {
    if (!server.requirepass) {
        addReplyError(c,"Client sent AUTH, but no password is set");
    } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
      c->authenticated = 1;
      addReply(c,shared.ok);
    } else {
      c->authenticated = 0;
      addReplyError(c,"invalid password");
    }
}

void pingCommand(redisClient *c) {
    addReply(c,shared.pong);
}
```


```c
// t_string.c 文件中
/* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */
void setCommand(redisClient *c) {

    ....
    
    // 尝试对值对象进行编码
    c->argv[2] = tryObjectEncoding(c->argv[2]);

    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}
```


```c
// t_hash.c 文件中
void hexistsCommand(redisClient *c) {
    robj *o;

    // 取出哈希对象
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,REDIS_HASH)) return;

    // 检查给定域是否存在
    addReply(c, hashTypeExists(o,c->argv[2]) ? shared.cone : shared.czero);
}

/* 
 * 检查给定域 feild 是否存在于 hash 对象 o 中。
 *
 * 存在返回 1 ，不存在返回 0 。
 */
int hashTypeExists(robj *o, robj *field) {

    // 检查 ziplist
    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) return 1;

    // 检查字典
    } else if (o->encoding == REDIS_ENCODING_HT) {
        robj *aux;

        if (hashTypeGetFromHashTable(o, field, &aux) == 0) return 1;

    // 未知编码
    } else {
        redisPanic("Unknown hash encoding");
    }
    // 不存在
    return 0;
}

```