---
layout:     page
title:      "Buffer Pool"
subtitle:   "《MySql是怎么样运行的》笔记：Buffer Pool"
date:       2025-12-06
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
    - 笔记
---


# 概述
InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。在进行完读写访问之后并不会马上释放该页对应的内存空间掉，而是将其缓存起来，当有请求再次访问该页面时，就可以省去磁盘IO的开销。


所以InnoDB为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，叫做Buffer Pool（中文名是缓冲池）。

默认情况下Buffer Pool只有128M大小。可在启动服务器的时候配置innodb_buffer_pool_size参数的值：

> [server]
> innodb_buffer_pool_size = 268435456


# Buffer Pool内部组成

Buffer Pool中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是16KB。

为了更好的管理，InnoDB为每一个缓存页都创建了一些所谓的控制信息，这些控制信息包括**该页所属的表空间编号、页号、缓存页在Buffer Pool中的地址、链表节点信息**、一些锁信息以及LSN信息。

每个缓存页对应的控制信息占用的内存（控制块）大小是相同的，控制块和缓存页是一一对应的。缓存页和控制块都被存放到 Buffer Pool 中，其中控制块在前，缓存页在后：

![image-20251206153342677]({{site.baseurl}}/img/in-post/article0016/image-20251206153342677.png)

PS: 设置的innodb_buffer_pool_size并不包含这部分控制块占用的内存空间大小

# free链表的管理

启动MySQL服务器时，需要完成对Buffer Pool的初始化过程，就是先向操作系统申请Buffer Pool的内存空间，然后把它划分成若干对控制块和缓存页。

通过设置 **free链表（串联缓存页的控制块）** 记录一下Buffer Pool中哪些缓存页是可用的。

刚刚完成初始化的Buffer Pool中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到free链表中。

![image-20251206153951917]({{site.baseurl}}/img/in-post/article0016/image-20251206153951917.png)

# 缓存页的哈希处理

Innodb通过对目标页面的 **表空间号 + 页号** 作为key, 缓存页 作为value，建立了一个哈希表。当需要判断目标页面是否已经进入buffer pool的时候，先从哈希表中根据**表空间号 + 页号**查看是否有对应的缓存页，有则使用该缓存页，没有则从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

# flush链表的管理

当修改了Buffer Pool中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页（英文名：dirty page）。

Innodb为了性能考虑，通过建立flush链表管理这些脏页，在某个时间点将flush链表中的脏页同步到磁盘中。

![image-20251206155044086]({{site.baseurl}}/img/in-post/article0016/image-20251206155044086.png)

# LRU链表的管理

因为Buffer pool的空间总是有限的free链表总会被使用完，幸好缓存页只是为了增加页面在内存中命中率，减少磁盘IO，可以将老旧的缓存页淘汰，再创建一个新的链表（LRU链表）。

## 简单的LRU链表
简单的LRU链表就是按照最近最少使用的原则去淘汰缓存页的：
- 设置新节点时，将节点设置到链表的头部。
- 访问链表中的节点时，将该节点移动到链表的头部。
- 淘汰节点时，直接淘汰链表尾部节点。

## 划分区域的LRU链表

上述的简单LRU链表在实际使用过程中效果并不好（命中率不高），部分原因如下：

- 情况一：InnoDB有预读（英文名：read ahead）的功能逻辑。即执行当前的请求可能之后会读取某些其他页面，就预先把它们加载到Buffer Pool中。根据触发方式的不同，预读又可以细分为下面两种：
    - 线性预读
    > InnoDB提供了一个系统变量innodb_read_ahead_threshold，如果顺序访问了某个区（extent）的页面超过这个值，就会触发一次**异步**读取下一个区中全部的页面到Buffer Pool的请求。
    - 随机预读
    
    > 如果已经缓存了某个区的13个连续的页面，都会触发一次**异步**读取本区中所有其的页面到Buffer Pool的请求。通过innodb_random_read_ahead系统变量控制开关，默认值为OFF。
- 情况二：扫描全表的查询语句等。

总结一下上面说的可能降低Buffer Pool的两种情况：
- 加载到Buffer Pool中的页不一定被用到。
- 使用频率偏低的页可能会把那些使用频率非常高的页中淘汰掉。

为了处理上述情况，InnoDB的把这个LRU链表按照一定比例分成两截：
- 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做热数据，或者称young区域。
- 一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做冷数据，或者称old区域。

![image-20251206161158956]({{site.baseurl}}/img/in-post/article0016/image-20251206161158956.png)

划分成young和old区域的LRU链表之后，InnoDB就针对上面提到的两种可能降低缓存命中率的情况进行优化了：

- 针对预读的页面可能不进行后续访情况的优化
    > InnoDB规定，当某个页面在**初次加载到Buffer Pool中的某个缓存页时**，该控制块会被放到**old区域的头部**。
- 针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化
    > 在对某个处在old区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量innodb_old_blocks_time控制的。

PS： 
- 可以通过在修改innodb_old_blocks_pct参数来控制old区域在LRU链表中所占的比例：
    > [server]
    > innodb_old_blocks_pct = 40

- InnoDB规定每次去页面中读取一条记录时，都算是访问一次页面，而一个页面中可能会包含很多条记录，即读取完某个页面的记录就相当于访问了这个页面好多次。


## 更进一步优化LRU链表
在young区域的缓存页，为了减少每次移动节点的开销，只有被访问的缓存页位于young区域的1/4的后边，才会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从而提升性能。
其他优化措施等等。

# 刷新脏页到磁盘

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘。主要有两种刷新路径：

- 从LRU链表的冷数据中刷新一部分页面到磁盘。
    > 后台线程会定时从LRU链表尾部开始扫描一些页面，扫描的页面数量通过系统变量innodb_lru_scan_depth来指定，如果发现脏页，会把它们刷新到磁盘。该方式为BUF_FLUSH_LRU。
- 从flush链表中刷新一部分页面到磁盘。
    > 后台线程也会定时从flush链表中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。该方式为BUF_FLUSH_LIST。

- 有时候当用户线程需要从LRU链表中淘汰页面时，如果没有可以直接释放的页面（未修改页面），就只能将LRU链表尾部的一个脏页同步刷新到磁盘。该方式为BUF_FLUSH_SINGLE_PAGE。

- 甚至：有时候系统特别繁忙时，也可能出现用户线程批量的从flush链表中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为。

# 多个Buffer Pool实例
Buffer Pool本质是InnoDB向操作系统申请的一块连续的内存空间，在多线程环境下，访问Buffer Pool中的各种链表都需要加锁处理什么的，在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。

所以在Buffer Pool特别大的时候，我们可以把它们拆分成若干个小的Buffer Pool，每个Buffer Pool都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表等等，所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

我们可以在服务器启动的时候通过设置innodb_buffer_pool_instances的值来修改Buffer Pool实例的个数，比方说这样：

> [server]
> innodb_buffer_pool_instances = 2

![image-20251206163557337]({{site.baseurl}}/img/in-post/article0016/image-20251206163557337.png)

那每个Buffer Pool实例实际占内存空间可以通过公式算出来的：
> innodb_buffer_pool_size/innodb_buffer_pool_instances

也就是总共的大小除以实例的个数，结果就是每个Buffer Pool实例占用的大小。

InnoDB规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。而我们鼓励在Buffer Pool大小或等于1G的时候设置多个Buffer Pool实例。

PS: **数据页通过哈希算法分配到不同实例中，所以一个数据页之后被缓存在一个Buffer Pool实例中**


# innodb_buffer_pool_chunk_size

在MySQL 5.7.5之前，Buffer Pool的大小只能在启动时通过配置innodb_buffer_pool_size参数调整大小，运行时是不允许调整该值的。

在5.7.5以及之后的版本，一个Buffer Pool实例其实是由若干个chunk组成的，一个chunk就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块：

![image-20251206164831939]({{site.baseurl}}/img/in-post/article0016/image-20251206164831939.png)

上图代表的Buffer Pool就是由2个实例组成的，每个实例中又包含2个chunk。

在运行期间调整Buffer Pool的大小时就是以chunk为单位增加或者删除内存空间，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。

PS: 
- chunk的大小是只能在服务器启动时指定, 通过innodb_buffer_pool_chunk_size参数设置，默认值是134217728，也就是128M。
- 每个Buffer Pool实例中的chunk数量相等，Mysql会通过调整参数来保证

# 配置Buffer Pool时的注意事项

- innodb_buffer_pool_size必须是innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances的倍数（为了保证每一个Buffer Pool实例中包含的chunk数量相同）。
- 如果在服务器启动时，innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances的值已经大于innodb_buffer_pool_size的值，那么innodb_buffer_pool_chunk_size的值会被服务器自动设置为innodb_buffer_pool_size/innodb_buffer_pool_instances的值。

# 查看Buffer Pool的状态信息

MySQL提供了SHOW ENGINE INNODB STATUS语句来查看关于InnoDB存储引擎运行过程中的一些状态信息，其中就包括Buffer Pool的一些信息：
```
mysql> SHOW ENGINE INNODB STATUS\G

(...省略前面的许多状态)
----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 13218349056;
Dictionary memory allocated 4014231
Buffer pool size   786432
Free buffers       8174
Database pages     710576
Old database pages 262143
Modified db pages  124941
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 6195930012, not young 78247510485
108.18 youngs/s, 226.15 non-youngs/s
Pages read 2748866728, created 29217873, written 4845680877
160.77 reads/s, 3.80 creates/s, 190.16 writes/s
Buffer pool hit rate 956 / 1000, young-making rate 30 / 1000 not 605 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 710576, unzip_LRU len: 118
I/O sum[134264]:cur[144], unzip sum[16]:cur[0]
--------------
(...省略后边的许多状态)
```

- Total memory allocated：代表Buffer Pool向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。
- Dictionary memory allocated：为数据字典信息分配的内存空间大小，注意这个内存空间和Buffer Pool没什么关系，不包括在Total memory allocated中。
- Buffer pool size：代表该Buffer Pool可以容纳多少缓存页，注意，单位是页！
- Free buffers：代表当前Buffer Pool还有多少空闲缓存页，也就是free链表中还有多少个节点。
- Database pages：代表LRU链表中的页的数量，包含young和old两个区域的节点数量。
- Old database pages：代表LRU链表old区域的节点数量。
- Modified db pages：代表脏页数量，也就是flush链表中节点的数量。
- Pending reads：正在等待从磁盘上加载到Buffer Pool中的页面数量。 当准备从磁盘中加载某个页面时，会先为这个页面在Buffer Pool中分配一个缓存页以及它对应的控制块，然后把这个控制块添加到LRU的old区域的头部，但是这个时候真正的磁盘页并没有被加载进来，Pending reads的值会跟着加1。
- Pending writes LRU：即将从LRU链表中刷新到磁盘中的页面数量。
- Pending writes flush list：即将从flush链表中刷新到磁盘中的页面数量。
- Pending writes single page：即将以单个页面的形式刷新到磁盘中的页面数量。
- Pages made young：代表LRU链表中曾经从old区域移动到young区域头部的节点数量。
- Page made not young：在将innodb_old_blocks_time设置的值大于0时，首次访问或者后续访问某个处在old区域的节点时由于不符合时间间隔的限制而不能将其移动到young区域头部时，Page made not young的值会加1。
- youngs/s：代表每秒从old区域被移动到young区域头部的节点数量。
- non-youngs/s：代表每秒由于不满足时间限制而不能从old区域移动到young区域头部的节点数量。
- Pages read、created、written：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。
- Buffer pool hit rate：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到Buffer Pool了。
- young-making rate：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到young区域的头部了。
- not (young-making rate)：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到young区域的头部。
- LRU len：代表LRU链表中节点的数量。
- unzip_LRU：代表unzip_LRU链表中节点的数量
- I/O sum：最近50s读取磁盘页的总数。
- I/O cur：现在正在读取的磁盘页数量。
- I/O unzip sum：最近50s解压的页面数量。
- I/O unzip cur：正在解压的页面数量。

# Buffer Pool 与 操作系统虚拟内存

Buffer Pool 和 虚拟内存 都是磁盘和物理内存的映射技术。不过虚拟内存是操作系统层级的，而Buffer Pool是针对自身应用专门优化的处理映射逻辑，其LRU逻辑跟符合InnoDB的逻辑，为了减少磁盘IO。

并且虚拟内存对比Buffer Pool：
- 无业务语义：OS不知道某个内存页是索引页、数据页还是undo页
- 粒度不匹配：OS通常4KB页，数据库常用16KB页（InnoDB默认）
- 虚拟内存无事务语义：不知道页是否已修改（脏页）、是否需要刷盘保证ACID
- 置换策略单一（LRU策略）：仅基于访问频率，不考虑数据重要性

# 总结
1. 磁盘太慢，用内存作为缓存很有必要。
2. Buffer Pool本质上是InnoDB向操作系统申请的一段连续的内存空间，可以通过innodb_buffer_pool_size来调整它的大小。
3. Buffer Pool向操作系统申请的连续内存由控制块和缓存页组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后，Buffer Pool剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为碎片。
4. InnoDB使用了许多链表来管理Buffer Pool。
5. free链表中每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到Buffer Pool时，会从free链表中寻找空闲的缓存页。
6. 为了快速定位某个页是否被加载到Buffer Pool，使用表空间号 + 页号作为key，缓存页作为value，建立哈希表。
7. 在Buffer Pool中被修改的页称为脏页，脏页并不是立即刷新，而是被加入到flush链表中，待之后的某个时刻同步到磁盘上。
8. LRU链表分为young和old两个区域，可以通过innodb_old_blocks_pct来调节old区域所占的比例。首次从磁盘上加载到Buffer Pool的页会被放到old区域的头部，在innodb_old_blocks_time间隔时间内访问该页不会把它移动到young区域头部。在Buffer Pool没有可用的空闲缓存页时，会首先淘汰掉old区域的一些页。
9. 我们可以通过指定innodb_buffer_pool_instances来控制Buffer Pool实例的个数，每个Buffer Pool实例中都有各自独立的链表，互不干扰。
10. 自MySQL 5.7.5版本之后，可以在服务器运行过程中调整Buffer Pool大小。每个Buffer Pool实例由若干个chunk组成，每个chunk的大小可以在服务器启动时通过启动参数调整。
11. 可以用下面的命令查看Buffer Pool的状态信息：

> SHOW ENGINE INNODB STATUS\G