---
layout:     page
title:      "Innodb的事务隔离和MVCC"
subtitle:   "《MySql是怎么样运行的》笔记：Innodb的事务隔离和MVCC"
date:       2025-12-14
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
    - 笔记
---

# 事务隔离级别

## 事务并发执行遇到的问题

- 脏写（Dirty Write）：如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写。
- 脏读（Dirty Read）：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读。
- 不可重复读（Non-Repeatable Read）：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读。
- 幻读（Phantom）：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。


## SQL标准中的四种隔离级别

行业标准中设立了4个隔离级别：
- READ UNCOMMITTED：未提交读。
- READ COMMITTED：已提交读。
- REPEATABLE READ：可重复读。
- SERIALIZABLE：可串行化。

SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

| 隔离级别         | 脏读   | 不可重复读 | 幻读   |
| ---------------- | ------ | ---------- | ------ |
| READ UNCOMMITTED | 可能   | 可能       | 可能   |
| READ COMMITTED   | 不可能 | 可能       | 可能   |
| REPEATABLE READ  | 不可能 | 不可能     | 可能   |
| SERIALIZABLE     | 不可能 | 不可能     | 不可能 |

## MySQL中支持的四种隔离级别

MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的。

MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。

可以通过下面的语句修改事务的隔离级别：
> SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;

其中的level可选值有4个：
```
level: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}
```

设置事务的隔离级别的语句中，在SET关键字后可以放置GLOBAL关键字、SESSION关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，：

- 使用GLOBAL关键字（在全局范围影响）
则：只对执行完该语句之后产生的会话起作用。当前已经存在的会话无效。

- 使用SESSION关键字（在会话范围影响）：对当前会话的所有后续的事务有效
，但不会影响当前正在执行的事务。

- 上述两个关键字都不用（只对执行语句后的下一个事务产生影响）

# MVCC原理

## 版本链

使用InnoDB存储引擎的表，聚簇索引记录中都包含两个必要的隐藏列：
- trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
- roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

![image-20251214160711703]({{site.baseurl}}/img/in-post/article0019/image-20251214160711703.png)

- is_insert：表示该指针指向的undo日志是否是TRX_UNDO_INSERT大类的日志。
- rseg id：表示该指针指向的undo日志的回滚段编号。
- page number：表示该指针指向的undo日志所在页面的页号。
- offset：表示该指针指向的undo日志在页面中的偏移量。

![image-20251214161007904]({{site.baseurl}}/img/in-post/article0019/image-20251214161007904.png)

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。

## ReadView

这个ReadView用于判断那些数据对于当前事务是不可见的：

- m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
- min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
- max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
- creator_trx_id：表示生成该ReadView的事务的事务id。

有了这个ReadView，这样在访问某条记录时，只需要按照下面的步骤判断记录的某个版本是否可见：

- 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。


**如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上面的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。**

不同的事务级别对应不同是ReadView生成的实际。

- READ COMMITTED —— 每次读取数据前都生成一个ReadView
- REPEATABLE READ —— 在第一次读取数据时生成一个ReadView


MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行**普通的SEELCT操作**时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。


## 二级索引与MVCC

只有在聚簇索引中才有trx_id和roll_pointer隐藏列，如果查询二级索引时要如何判断可见性呢：

1. 二级索引页面的Page Header部分有一个名为 PAGE_MAX_TRX_ID的属性，表示对该页面修改最大的事务ID。在查询时如果ReadView中的min_trx_id 大于 PAGE_MAX_TRX_ID，说明该页所有记录对该ReadView都可见，否则**就需要进行回表进行判断**
2. 利用二级索引的主键值进行回表，通过MVCC进行判断可见性。