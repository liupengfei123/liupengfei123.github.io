---
layout:     page
title:      "Innodb---锁"
subtitle:   "《MySql是怎么样运行的》笔记：Innodb---锁"
date:       2025-12-14
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
    - 笔记
---

# 解决并发事务问题的两种基本方式

## 写-写情况
多个未提交事务相继对一条记录做改动时，需要让它们排队执行，通过锁来实现的。这个锁是一个内存中的结构。

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联， **通过哈希表的方式将行记录（space_id，page_no，heap_no）与锁结构进行关联**。

![image-20251214211612311]({{site.baseurl}}/img/in-post/article0020/image-20251214211612311.png)

其实在锁结构里有很多信息，其中两个比较重要的属性拿了出来：

- trx信息：代表这个锁结构是哪个事务生成的。
- is_waiting：代表当前事务是否在等待。

当另一个事务进行竞争锁：

![image-20251214211559329]({{site.baseurl}}/img/in-post/article0020/image-20251214211559329.png)

## 读-写或写-读情况
一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。

其实有两种可选的解决方案：
- 方案一：读操作利用多版本并发控制（MVCC），**写操作进行加锁**。
- 方案二：读、写操作都采用加锁的方式。

## 一致性读（Consistent Reads）

事务利用MVCC进行的读取操作称之为一致性读，或者一致性无锁读，也有称为快照读。**所有普通的SELECT语句（plain SELECT）在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读**。

一致性读并不会对表中的任何记录做加锁操作，其他事务可以自由的对表中的记录做改动。

## 锁定读（Locking Reads）

### 共享锁和独占锁

- 共享锁，Shared  Locks，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。
- 独占锁，也常称排他锁，Exclusive Locks，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。

S锁和S锁是兼容的，S锁和X锁是不兼容的，X锁和X锁也是不兼容的。

| 兼容性 | X      | S      |
| ------ | ------ | ------ |
| X      | 不兼容 | 不兼容 |
| S      | 不兼容 | 兼容   |

### 锁定读的语句

- 对读取的记录加S锁：
> SELECT ... LOCK IN SHARE MODE;
- 对读取的记录加X锁：
> SELECT ... FOR UPDATE;

## 写操作
写操作无非是DELETE、UPDATE、INSERT这三种：

- DELETE：对一条记录做DELETE操作是先在B+树中定位到该记录位置，然后获取该记录的X锁，然后再执行delete mark操作。
- UPDATE：在对一条记录做UPDATE操作时分为三种情况：
    - 修改主键且原地更新的情况，先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。
    - 未修改主键且不能原地更新的情况，先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。
    - 修改主键的情况，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。
- INSERT：新插入一条记录的操作并不加锁，InnoDB通过一种隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问。


# 多粒度锁
除了可以给行记录加锁（行锁）外，还可以给整个表级别进行加锁（表锁），表锁也分为共享锁（S锁）和独占锁（X锁）。

应该在上表锁时，是不能有不兼容的行锁存在的，所以innodb设计了意向锁（Intention Locks）：

- 意向共享锁，Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。
- 意向独占锁，Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。

**意向锁并无锁互斥的功能，更多的是打个标记，表示有存在对应的行锁。**：
意向共享锁（IS）、意向独占锁(IX）是表级锁，它们仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录。

# MySQL中的行锁和表锁
## 其他存储引擎中的锁
对于MyISAM、MEMORY、MERGE这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。

## InnoDB存储引擎中的锁

### InnoDB中的表级锁

#### 表级别的S锁、X锁
对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的DDL语句时，是通过在server层使用一种称之为元数据锁（Metadata Locks，简称MDL）实现的，一般情况下也不会使用InnoDB存储引擎自己提供的表级别的S锁和X锁。

手动获取，比方说在系统变量autocommit=0，innodb_table_locks = 1时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁：
- LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。
- LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。

尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。

#### 表级别的IS锁、IX锁
意向锁已说明

#### 表级别的AUTO-INC锁
为表的某个列添加AUTO_INCREMENT属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值。

系统实现这种自动给AUTO_INCREMENT修饰的列递增赋值的原理主要是两个：

- 采用AUTO-INC锁，也就是在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在**该语句执行结束后，再把AUTO-INC锁释放掉**。这样一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。
- 采用一个轻量级的锁，在为插入语句生成AUTO_INCREMENT修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的AUTO_INCREMENT列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。

PS：InnoDB提供了一个innodb_autoinc_lock_mode的系统变量来控制使用上述两种方式中哪一种，当为0时，一律采用AUTO-INC锁；当为2时，一律采用轻量级锁；当为1时，两种方式混着来（也就是在插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁）。**不过当值为2时，可能会造成不同事务中的插入语句时对应列生成的值是交叉的，在有主从复制的场景中是不安全的。**

### InnoDB中的行级锁

![image-20251214215021334]({{site.baseurl}}/img/in-post/article0020/image-20251214215021334.png)

#### Record Locks

记录锁就是仅仅把一条记录锁上，LOCK_REC_NOT_GAP（这里不严谨的称呼为：正经记录锁）

![image-20251214214936286]({{site.baseurl}}/img/in-post/article0020/image-20251214214936286.png)

正经记录锁是有S锁和X锁之分的，分别称之为S型正经记录锁和X型正经记录锁。

#### Gap Locks

在处理幻读问题时，在采用加锁方案解决会有一个问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，无法给这些幻影记录加上正经记录锁。所以InnoDB设计Gap Locks锁（LOCK_GAP），这里简称为gap锁。

![image-20251214215003655]({{site.baseurl}}/img/in-post/article0020/image-20251214215003655.png)

如图中记录加了gap锁，意味着不允许别的事务在该条记录前面的间隙插入新记录，即主键值(3, 8)这个区间的新记录是不允许立即插入的。

**这个gap锁的提出仅仅是为了防止插入幻影记录而提出的**，虽然有共享gap锁和独占gap锁这样的说法，但是它们作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享、独占gap锁），并不会限制其他事务对这条记录加正经记录锁或者继续加gap锁。

#### Next-Key Locks

既想锁住某条记录，又想阻止其他事务在该记录前面的间隙插入新记录，所以设计Next-Key Locks的锁（LOCK_ORDINARY），简称为next-key锁。

![image-20251214215611212]({{site.baseurl}}/img/in-post/article0020/image-20251214215611212.png)

next-key锁的本质就是一个正经记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前面的间隙。

#### Insert Intention Locks

一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁，如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。

**但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待**。InnoDB把这种锁命名为Insert Intention Locks，（LOCK_INSERT_INTENTION），简称为插入意向锁。

![image-20251214221017464]({{site.baseurl}}/img/in-post/article0020/image-20251214221017464.png)

#### 隐式锁
除了阻塞于Gap锁加的插入意向锁，一般情况下INSERT操作是不加锁的。那如果一个事务首先插入了一条记录，然后另一个事务：

- 立即使用SELECT ... LOCK IN SHARE MODE语句读取这条事务，也就是在要获取这条记录的S锁，或者使用SELECT ... FOR UPDATE语句读取这条事务或者直接修改这条记录，**使用锁语句时就不使用MVCC了直接读取最新值，就有可能导致脏读，脏写**

所以事务id又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：
- 情景一：对于聚簇索引记录来说，有一个trx_id隐藏列。如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是**当前的活跃事务**，如果是的话，那么就帮助当前事务创建一个X锁（为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。
- 情景二：对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性，该属性代表对该页面做改动的最大的事务id，如果PAGE_MAX_TRX_ID属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。

所以一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id存在，相当于加了一个隐式锁。别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

### InnoDB锁的内存结构

InnoDB决定在对不同记录加锁时，如果符合下面这些条件：
- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的

那么这些记录的锁就可以被放到一个锁结构中。

![image-20251214220959303]({{site.baseurl}}/img/in-post/article0020/image-20251214220959303.png)

- 锁所在的事务信息：锁都是在事务执行过程中生成的，指向生成该锁的事务对象指针。
- 索引信息：对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。
- 表锁／行锁信息：表锁结构和行锁结构在这个位置的内容是不同的：
    - 表锁：记载着这是对哪个表加的锁，还有其他的一些信息。
    - 行锁：记载了三个重要的信息：
        - Space ID：记录所在表空间。
        - Page Number：记录所在页号。
        - n_bits：对于行锁来说，一条记录就对应着一个比特位。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。
- type_mode：这是一个32位的数，被分成了lock_mode、lock_type和rec_lock_type三个部分：
  ![image-20251214221849514]({{site.baseurl}}/img/in-post/article0020/image-20251214221849514.png)
    - 锁的模式（lock_mode），占用低4位，可选的值如下：
        - LOCK_IS（十进制的0）：表示共享意向锁，也就是IS锁。
        - LOCK_IX（十进制的1）：表示独占意向锁，也就是IX锁。
        - LOCK_S（十进制的2）：表示共享锁，也就是S锁。
        - LOCK_X（十进制的3）：表示独占锁，也就是X锁。
        - LOCK_AUTO_INC（十进制的4）：表示AUTO-INC锁。
    - 锁的类型（lock_type），占用第5～8位：
        - LOCK_TABLE（十进制的16），也就是当第5个比特位置为1时，表示表级锁。
        - LOCK_REC（十进制的32），也就是当第6个比特位置为1时，表示行级锁。
    - 行锁的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：
        - LOCK_ORDINARY（十进制的0）：表示next-key锁。
        - LOCK_GAP（十进制的512）：也就是当第10个比特位置为1时，表示gap锁。
        - LOCK_REC_NOT_GAP（十进制的1024）：也就是当第11个比特位置为1时，表示正经记录锁。
        - LOCK_INSERT_INTENTION（十进制的2048）：也就是当第12个比特位置为1时，表示插入意向锁。
        - **LOCK_WAIT（十进制的256） ：也就是当第9个比特位置为1时，表示is_waiting为true，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0时，表示is_waiting为false，也就是当前事务获取锁成功。**
- 一堆比特位：如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上面提到的n_bits属性表示的。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，不过为了编码方便，映射方式有点怪：

![image-20251214222125451]({{site.baseurl}}/img/in-post/article0020/image-20251214222125451.png)

### 如何判断记录是否被锁

InnoDB的锁系统维护了一个锁等待表和锁哈希表。锁哈希表根据锁对象的标识（如表锁，或者行锁的页号等）将锁结构哈希起来，以便快速查找。

当要判断一行是否被锁住时，InnoDB会通过行所在的位置信息（表空间、页号）在锁哈希表中查找是否有锁结构， 在通过锁结构通过heap_no查找该记录是否被锁。

```
// 伪代码流程
bool is_record_locked(space_id, page_no, heap_no) {
    // 1. 在哈希表中查找该页的所有锁
    lock = lock_rec_get_first(lock_sys->rec_hash, 
                             space_id, page_no);
    
    while (lock != NULL) {
        // 2. 检查位图中该heap_no位是否被设置
        if (lock_rec_get_nth_bit(lock, heap_no)) {
            // 3. 检查锁模式和事务状态
            if (lock->trx->state != TRX_STATE_COMMITTED) {
                return true;  // 记录被锁
            }
        }
        lock = lock_rec_get_next(heap_no, lock);
    }
    return false;
}
```


# 语句加锁分析

## 普通的SELECT语句
在不同隔离级别下，有不同表现：

- READ UNCOMMITTED：不加锁；直接读取记录的最新版本；可能出现脏读、不可重复读和幻读
- READ COMMITED：不加锁；每次查询时会生成一个 ReadView，避免了脏读，可能会出现不可重复读和幻读
- REPAEATABLE READ：不加锁；只在第一次查询时生成一个 ReadView，避免了脏读、不可重复读和幻读。
-  SERIALIZABLE：
    -  autocommit = 0，禁用自动提交时，普通 SELECT 会被转换为 SELECT……LOCK IN SHARE MODE 获取 S 锁，具体加锁情况与 REPAEATABLE READ 一致。
    -  autocommit = 1，启用自动提交时，不加锁，会生成 ReadView 来读取记录，这时一个事务中只包含一条语句，也就不会出现不可重复记、幻读的现象了。

在 REPAEATABLE READ 隔离级别下 并不能完全避免幻读现象：
```
步骤一：T1 第一次执行普通的 SELECT 语句查询 R1，结果为空

步骤二：T2 向表中新插入一条记录 R1 并提交。

步骤三：T1 对 R1 记录执行update语句

步骤四：T1 第二次执行普通SELECT语句查询 R1，结果查询到update修改后的结果
```

原因是步骤二，执行insert语句之后事务马上提交了所以没有隐式锁了，在步骤三因为是update语句使用锁结构所以不使用MVCC，直接读取的最新值，所以该update语句可以命中R1记录并且修改，就将最新的R1记录中的TR_ID更新T1，就导致步骤四的select的ReadView可以扫描到R1记录。


# 查看事务加锁情况
## 方式一
使用information_schema数据库中的表获取锁信息。
有以下表记录锁信息：
1. INNODB_TRX：存储了 InnoDB 存储引擎当前正在执行的事务信息
2. INNODB_LOCKS：记录了锁信息
3. INNODB_LOCK_WAITS：表明每个阻塞的事务是因为获取不到哪个事务持有的锁而阻塞

## 方式二 
使用 SHOW ENGINE INNODB STATUS 获取锁信息
> SHOW ENGINE INNODB STATUS;

# 死锁

InnoDB 有一个死锁检测机制，当它检测到死锁发生时，会选择一个较小的事务进行回滚，并向客户端发送一条消息
> ERROR 1212 (40001): Deadlock found when trying to get lock; try restarting transaction

使用 SHOW ENGINE INNODB STATUS 语句来查看最近发生的一次死锁信息

















