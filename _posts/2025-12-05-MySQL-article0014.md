---
layout:     page
title:      "Innodb的存储结构"
subtitle:   "《MySql是怎么样运行的》笔记：Innodb的存储结构"
date:       2025-12-05
author:     "Lpf"
header-img: "img/home-bg.jpg"
tags:
    - MySQL
---

# 概述

InnoDB是一个将表中的数据存储到磁盘上的存储引擎，而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。所以Mysql将数据划分为连续的若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小默认为 16KB。

在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等。

该文章我们聚焦的是那些存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（INDEX）页


# 记录存储

Mysql以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。

行格式4种格式：Compact、Redundant、Dynamic、Compressed

MySQL 从 5.7 版本开始，InnoDB 存储引擎的默认行格式（row format）从 COMPACT 更改为 DYNAMIC。

## 指定行格式
我们可以在创建或修改表的语句中指定行格式：
```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

## COMPACT行格式

![image-20251205130432476]({{site.baseurl}}/img/in-post/article0014/image-20251205130432476.png)

一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。


### 变长字段长度列表
MySQL支持一些变长的数据类型，比如VARCHAR(M)等，数据类型为上述类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，所以需要把数据所占用的字节数也存起来。


在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**！

即：列3长度，列2长度，列1长度|...|列1数据，列2数据，列3数据

因为在列表中各长度数据是紧密排列的，需要通过一种方式来区分出各个长度：

> 如果该可变字段允许存储的最大字节数（最大字符数 M ×  一个字符的最大字节数 W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节。  

PS: 
1. InnoDB在读记录的变长字段长度列表时先查看表结构, 就可以知道 M × W 的值。
2. 当 M × W > 255 时，读取到字节的最高位为0是说明该长度是使用一个字节，否则使用两个字节表示长度
3. 对于占用字节数非常多的字段，会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。


### NULL值列表

Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，它的处理过程是这样的：
1. 首先统计表中允许存储NULL的列有哪些
2. 如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下:
    - 二进制位的值为1时，代表该列的值为NULL。
    - 二进制位的值为0时，代表该列的值不为NULL。

![image-20251205130444616]({{site.baseurl}}/img/in-post/article0014/image-20251205130444616.png)

PS: 
1. InnoDB在读记录的NULL值列表时先查看表结构, 就可以知道那些列是可以为NULL值。

### 记录头信息

记录头信息由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思

![image-20251205130459129]({{site.baseurl}}/img/in-post/article0014/image-20251205130459129.png)

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位1      | 1                 | 没有使用                                                     |
| 预留位2      | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned      | 4                 | 表示当前记录拥有的记录数()                                   |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息（**锁结构中使用**）           |
| record_type  | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置（指向的位置是记录的额外信息和真实数据之间） |



### 记录的真实数据
记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：

| 列名        | 是否必须 | 占用空间 | 描述                   |
| ----------- | -------- | -------- | ---------------------- |
| DB_ROW_ID   | 否       | 6字节    | 行ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6字节    | 事务ID                 |
| DB_ROLL_PTR | 是       | 7字节    | 回滚指针               |

InnoDB表对主键的生成策略：
- 优先使用用户自定义主键作为主键，
- 如果用户没有定义主键，则选取一个Unique键作为主键，
- 如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。

### CHAR(M)列的存储格式
变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)却没有这个要求。

## Dynamic和Compressed行格式
这俩行格式和Compact行格式基本一致，只不过在处理行溢出数据时有点儿不同，它们把溢出列的所有字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![image-20251205130509707]({{site.baseurl}}/img/in-post/article0014/image-20251205130509707.png)

Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。


## Redundant行格式

Redundant行格式是MySQL5.0之前用的一种行格式。

![image-20251205130517254]({{site.baseurl}}/img/in-post/article0014/image-20251205130517254.png)


### 字段长度偏移列表

字段长度偏移列表实质上是存储**每个列**中的值占用的空间在记录的真实数据处结束的位置。

字段长度偏移列表中的各个列对应的偏移量中最高比特位作为是否为NULL的依据，该比特位也可以被称之为NULL比特位。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1，如果为1，那么该列的值就是NULL，否则不是NULL。所以当真实数据大于127时需要使用2个字节，否则使用1个字节（通过1byte_offs_flag判断使用1个还是两个字节）。

### 记录头信息
Redundant行格式的记录头信息占用6字节，48个二进制位，这些二进制位代表的意思如下：

| 名称            | 大小（单位：bit） | 描述                                                         |
| --------------- | ----------------- | ------------------------------------------------------------ |
| 预留位1         | 1                 | 没有使用                                                     |
| 预留位2         | 1                 | 没有使用                                                     |
| delete_mask     | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask    | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| n_owned         | 4                 | 表示当前记录拥有的记录数()                                   |
| heap_no         | 13                | 表示当前记录在记录堆的位置信息（**锁结构中使用**）           |
| n_field         | 10                | 表示记录中列的数量                                           |
| 1byte_offs_flag | 1                 | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的，为1使用1个字节，为0是用两个字节 |
| next_record     | 16                | 表示下一条记录的相对位置（指向的位置是记录的额外信息和真实数据之间） |


###  记录的真实数据
同 COMPACT 格式

### CHAR(M)列的存储格式
使用CHAR(M)类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。比方说使用utf8字符集的CHAR(10)类型的列占用的真实数据空间始终为30个字节。由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是不会产生碎片的。


## 行溢出数据
在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，


![image-20251205130537263]({{site.baseurl}}/img/in-post/article0014/image-20251205130537263.png)

# Index页（索引页）

用于存储数据及数据目录的页面，其一个表索引的所有Index页节点构成了一颗B+树。

## 索引页结构

 数据页代表的这块16KB大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![image-20251205131318804]({{site.baseurl}}/img/in-post/article0014/image-20251205131318804.png)

从图中可以看出，一个InnoDB数据页的存储空间大致被划分成了7个部分。

| 名称               | 中文名             | 占用空间大小               | 简单描述                 |
| ------------------ | ------------------ | -------------------------- | ------------------------ |
| File Header        | 文件头部           | 38字节                     | 页的一些通用信息         |
| Page Header        | 页面头部           | 56字节                     | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26字节	两个虚拟的行记录 |                          |
| User Records       | 用户记录           | 不确定                     | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定                     | 页中尚未使用的空间       |
| Page Directory     | 页面目录           | 不确定                     | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8字节                      | 校验页是否完整           |

## Index页中的链表

数据记录会以**行格式**的形式紧密的存储在User Records区域。

![image-20251205131825713]({{site.baseurl}}/img/in-post/article0014/image-20251205131825713.png)

在上述的存放方式中，各个记录之间的顺序按照插入该页面的顺序。但是Innodb是需要快速查询的，所有需要对数据记录进行数值上的排序。

### 记录头信息

在行格式中有5个字节的**记录头信息**，其中对页面中记录形成有序链表有作用的有以下字段：

| 名称        | 大小（单位：bit） | 描述                                                         |
| ----------- | ----------------- | ------------------------------------------------------------ |
| record_type | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录 |
| next_record | 16                | 表示下一条记录的相对位置                                     |


#### record_type
表示当前记录的类型，一共有4种类型的记录：
- 0 表示普通记录
- 1 表示B+树非叶节点记录（目录记录）
- 2 表示最小记录（Infimum记录）
- 3 表示最大记录（Supremum记录）

#### next_record

表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。通过next_record就形成了一条按照主键值由小到大的链表。

而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）

比如说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。

![image-20251205133230086]({{site.baseurl}}/img/in-post/article0014/image-20251205133230086.png)

## Index页内的二分查找

为了更快速的在Index页中查找记录，Innodb通过在 **Page Directory（页目录）** 中设置了槽（Slot）用于实现二分查找。


Slot目录制作过程是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到Page Directory。页面目录中的这些地址偏移量被称为槽（英文名：Slot）。

![image-20251205134437658]({{site.baseurl}}/img/in-post/article0014/image-20251205134437658.png)

从这个图中我们需要注意这么几点：

- 现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。
- 注意最小和最大记录的头信息中的n_owned属性
    - 最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。
    - 最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。

### n_owned

InnoDB的对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。

所以分组是按照下面的步骤进行的：
- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

### 二分查找流程

因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。

4个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：

1. 计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 > 6，所以设置high=2，low保持不变。
2. 重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 < 6，所以设置low=1，high保持不变。
3. 因为high - low的值为1，所以确定主键值为5的记录在槽2对应的组中。从该槽中最小的那条记录，然后沿着单向链表遍历槽2中的记录，即可查找目标记录。

PS: 每个槽的上一个槽的下一条记录即为该槽的最小记录。


所以在一个数据页中查找指定主键值的记录的过程分为两步：
1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
2. 通过记录的next_record属性遍历该槽所在的组中的各个记录。

## Page Header（页面头部）

InnoDB为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

| 名称              | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2字节        | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2字节        | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space   |
| PAGE_N_HEAP       | 2字节        | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| PAGE_FREE         | 2字节        | 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | 2字节        | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2字节        | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2字节        | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | 2字节        | 一个方向连续插入的记录数量                                   |
| PAGE_N_RECS       | 2字节        | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| PAGE_MAX_TRX_ID   | 8字节        | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| PAGE_LEVEL        | 2字节        | 当前页在B+树中所处的层级                                     |
| PAGE_INDEX_ID     | 8字节        | 索引ID，表示当前页属于哪个索引                               |
| PAGE_BTR_SEG_LEAF | 10字节       | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| PAGE_BTR_SEG_TOP  | 10字节       | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

在这里我们先介绍一下PAGE_DIRECTION和PAGE_N_DIRECTION的意思：

- PAGE_DIRECTION
> 假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。

- PAGE_N_DIRECTION
> 假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。


## File Header（文件头部）
File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦等等～ 这个部分占用固定的38个字节，是由下面这些内容组成的：

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4字节        | 页的校验和（checksum值）                                     |
| FIL_PAGE_OFFSET                  | 4字节        | 页号                                                         |
| FIL_PAGE_PREV                    | 4字节        | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4字节        | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8字节        | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2字节        | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8字节        | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4字节        | 页属于哪个表空间                                             |

对照着这个表格，我们看几个目前比较重要的部分：


- FIL_PAGE_OFFSET
> 每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。

- FIL_PAGE_TYPE
> 这个代表当前页的类型，InnoDB为了不同的目的而把页分为不同的类型，具体如下表：

| 类型名称                | 十六进制 | 描述                           |
| ----------------------- | -------- | ------------------------------ |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用             |
| FIL_PAGE_UNDO_LOG       | 0x0002   | Undo日志页                     |
| FIL_PAGE_INODE          | 0x0003   | 段信息节点                     |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer空闲列表          |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer位图              |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                         |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据                   |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息                 |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页                     |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | BLOB页                         |
| FIL_PAGE_INDEX          | 0x45BF   | 索引页，也就是我们所说的数据页 |

- FIL_PAGE_PREV和FIL_PAGE_NEXT

> FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中介绍的INDEX页是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：

![image-20251205140530885]({{site.baseurl}}/img/in-post/article0014/image-20251205140530885.png)

PS: 在搜索范围值时，可以通过FIL_PAGE_PREV和FIL_PAGE_NEXT向前一页或者后一页继续查找。

即：**在B+树的叶子节点（INDEX页）中单个页中通过 next_record建立成有序单向链表，各个页之间通过FIL_PAGE_PREV和FIL_PAGE_NEXT建立成有序双向链表**

![image-20251205141212978]({{site.baseurl}}/img/in-post/article0014/image-20251205141212978.png)

# B+树索引结构

为了可以在各个Index页之间快速的查找记录，Innodb建立一个目录，建这个目录必须完成下面这些事儿：
- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。
- 给所有的页建立一个目录项。每一个Index页表示一个目录项，每个目录项中包含：页号（page_no）和Index页的用户记录中最小主键值。

![image-20251205151940089]({{site.baseurl}}/img/in-post/article0014/image-20251205151940089.png)

## InnoDB中的索引方案
InnoDB使用一种可以灵活管理所有目录项的方式。

因为目录项结构与用户记录差不多，所以复用了存储用户记录的数据页来存储目录项，为了和用户记录区分，把目录项的记录称为目录项记录。记录头信息里的record_type属性值为1表示目录项。

以此形成B+树，如下图：

![image-20251205152820763]({{site.baseurl}}/img/in-post/article0014/image-20251205152820763.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。目录项记录和普通的用户记录的不同点：

- 目录项记录的record_type值是1，而普通用户记录的record_type值是0。
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。
- 记录头信息中min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0。

除了上述几点外，这两者就没什么差别了，它们用的是一样的INDEX页，页的组成结构也是一样一样的，都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

### 聚簇索引

上面介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. B+树的叶子节点存储的是完整的用户记录。
    - 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。

这种聚簇索引并不需要显式的去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。

另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

### 二级索引

上面介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。

我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树。

这个B+树与上面介绍的聚簇索引有几处不同：
- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照c2列的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。
- B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。
- 目录项记录中不再是主键+页号的搭配，而变成了c2列+主键+页号的搭配。

### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：
- 先把各个记录和页按照c2列进行排序。
- 在记录的c2列相同的情况下，采用c3列进行排序


## InnoDB的B+树索引的注意事项

### 根页面万年不动窝

B+树的形成过程是这样的：

- 每当为某个表创建一个B+树索引的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
- 当**根节点**中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b。这时新插入的记录根据键值的大小就会被分配到页a或者页b中，而**根节点便升级为存储目录项记录的页**。

这个过程需要大家特别注意的是：**一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引**。

### 内节点中目录项记录的唯一性

为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：
- 索引列的值
- 主键值
- 页号

也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的：

### 一个页面最少存储2条记录

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度快！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录，那么是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。所以InnoDB的一个数据页至少可以存放两条记录。

# 表空间

表空间是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为表名.ibd的实际文件。

## 独立表空间结构
使用独立表空间存储表中的数据，那么会在该表所在数据库对应的子目录下创建一个名为 “表名.frm”的文件和一个名为“表名.ibd”的文件，表中的数据会存储这个“表名.ibd”文件中

### 区（extent）的概念

为了管理表空间数量众多的页，InnoDB的设计了区（英文名：extent）的概念。 对于16KB的页来说，连续的64个页就是一个区，即一个区默认占用1MB空间大小。

虽然Index页通过建立双向链表可以使随机分配的页串联起来，但是当需要读取页面数量很多时，会将资源浪费在随机IO上，所以**Innodb通过引入区的概念将逻辑相邻的页也尽可能的放在物理相邻的位置上，将随机IO转成顺序IO提升性能**

> 在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。

不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：

![image-20251205161244458]({{site.baseurl}}/img/in-post/article0014/image-20251205161244458.png)

extent 0 ~ extent 255这256个区算是第一个组，  
extent 256 ~ extent 511这256个区算是第二个组，  
extent 512 ~ extent 767这256个区算是第三个组，依此类推。

这些组的头几个页的类型都是类似的，就像这样：

![image-20251205161325442]({{site.baseurl}}/img/in-post/article0014/image-20251205161325442.png)

- **第一个组**最开始的**3个页**的类型是固定的分别是：
    - FSP_HDR类型：这个类型的页是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255这256个区的属性。**整个表空间只有一个FSP_HDR类型的页**。
    - IBUF_BITMAP类型：这个类型的页是存储本组所有的区的所有页关于INSERT BUFFER的信息。
    - INODE类型：这个类型的页存储了许多称为INODE的数据结构。。
- **其余各组**最开始的**2个页**的类型是固定的，分别是：
    - XDES类型：全称是extent descriptor，用来登记**本组256个区**的属性，上面介绍的FSP_HDR类型的页其实和XDES类型的页的作用类似。
    - IBUF_BITMAP类型。

### 段（segment）的概念

InnoDB对B+树的叶子节点和非叶子节点分别都做了处理：叶子节点有自己独有的区，非叶子节点也有自己独有的区。
> 存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

**段是以区为单位申请存储空间的，一个区默认占用1M存储空间**，为了不在数据量很少的表中造成浪费存储空间，InnoDB的设计**一个碎片（fragment）区**，即在一个碎片区中，存放混杂的页（有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于）。**碎片区直属于表空间，并不属于任何一个段**。所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页为单位来分配存储空间的。
- 当某个段已经占用了32个碎片区页之后，就会以完整的区为单位来分配存储空间。

所以段是某些零散的页以及一些完整的区的集合。


### 区的分类 

表空间的是由若干个区组成的，这些区大体上可以分为4种类型：

- 空闲的区：现在还没有用到这个区中的任何页。
- 有剩余空间的碎片区：表示碎片区中还有可用的页。
- 没有剩余空间的碎片区：表示碎片区中的所有页都被使用，没有空闲页。
- 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

这4种类型的区也可以被称为区的4种状态（State），设计InnoDB的大佬们为这4种状态的区定义了特定的名词儿：

| 状态名    | 含义                 |
| --------- | -------------------- |
| FREE      | 空闲的区             |
| FREE_FRAG | 有剩余空间的碎片区   |
| FULL_FRAG | 没有剩余空间的碎片区 |
| FSEG      | 附属于某个段的区     |

**处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，算是直属于表空间**；处于FSEG状态的区是附属于某个段的。


为了方便管理这些区，InnoDB设计了一个称为XDES Entry的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry结构。

![image-20251205163820777]({{site.baseurl}}/img/in-post/article0014/image-20251205163820777.png)

XDES Entry是一个40个字节的结构，大致分为4个部分，各个部分的释义如下：

- Segment ID（8字节）
> 每一个段都有一个唯一的编号，用ID表示，此处的Segment ID字段表示就是该区所在的段。

- List Node（12字节）
> 这个部分可以将若干个XDES Entry结构串联成一个链表。通过指定页号和页号中的页内偏移量确认上一个/下一个Entry结构的位置。

- State（4字节）
> 这个字段表明区的状态。分别是：FREE、FREE_FRAG、FULL_FRAG和FSEG。

- Page State Bitmap（16字节）
> 这个部分共占用16个字节，也就是128个比特位。一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。每一对第一个位表示对应的页是否是空闲的，第二个比特位还没有用。

#### XDES Entry链表

1. 在段数据很少，还在使用碎片区时，为了能快速定位可用的页，**表空间**维护了三个状态不同的链表：
    - FREE链表：把状态为FREE的区对应的XDES Entry结构通过List Node来连接成一个链表
    - FREE_FRAG链表：把状态为FREE_FRAG的区对应的XDES Entry结构通过List Node来连接成一个链表
    - FULL_FRAG链表：把状态为FULL_FRAG的区对应的XDES Entry结构通过List Node来连接成一个链表
2. 当段中数据已经占满了32个零散的页后，就使用完整的区来插入数据了，**每个段**中也维护了三个链表：
    - FREE链表：同一个段中，所有页都是空闲的区对应的XDES Entry结构会被加入到这个链表。
    - NOT_FULL链表：同一个段中，仍有空闲空间的区对应的XDES Entry结构会被加入到这个链表。
    - FULL链表：同一个段中，已经没有空闲空间的区对应的XDES Entry结构会被加入到这个链表。

**表空间**维护了碎片区的三个链表，
每一个索引对应两个段，**每个段**都会维护的三个链表。

#### 链表基节点
InnoDB设计了一个叫List Base Node的结构（链表的基节点）。这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息：

![image-20251205165701584]({{site.baseurl}}/img/in-post/article0014/image-20251205165701584.png)

- List Length表明该链表一共有多少节点，
- First Node Page Number和First Node Offset表明该链表的头节点在表空间中的位置。
- Last Node Page Number和Last Node Offset表明该链表的尾节点在表空间中的位置。

一般我们把**某个链表对应的List Base Node结构放置在表空间中固定的位置**。

### 段的结构

段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页以及一些完整的区组成。

像每个区都有对应的XDES Entry来记录这个区中的属性一样，InnoDB为每个段都定义了一个INODE Entry结构来记录一下段中的属性。

![image-20251205170053149]({{site.baseurl}}/img/in-post/article0014/image-20251205170053149.png)

它的各个部分释义如下：

- Segment ID
> 这个INODE Entry结构对应的段的编号（ID）。

- NOT_FULL_N_USED
> 指的是在NOT_FULL链表中已经使用了多少个页。

- 3个List Base Node
> 分别为段的FREE链表、NOT_FULL链表、FULL链表定义了List Base Node

- Magic Number：
> 用来标记这个INODE Entry是否已经被初始化了。如果这个数字是值的97937874，表明该INODE Entry已经初始化，否则没有被初始化。

- Fragment Array Entry
> 每个Fragment Array Entry结构都对应着一个零散的页，这个结构一共4个字节，表示一个零散页的页号。

### 各类型页详细情况

#### FSP_HDR类型页
首先看第一个组的第一个页(表空间的第一个页)，页号为0。这个页的类型是FSP_HDR，它存储了表空间的一些整体属性以及第一个组内256个区的对应的XDES Entry结构：

![image-20251205170656315]({{site.baseurl}}/img/in-post/article0014/image-20251205170656315.png)

| 名称              | 中文名     | 占用空间大小 | 简单描述                      |
| ----------------- | ---------- | ------------ | ----------------------------- |
| File Space Header | 表空间头部 | 112字节      | 表空间的一些整体属性信息      |
| XDES Entry        | 区描述信息 | 10240字节    | 存储本组256个区对应的属性信息 |

##### File Space Header部分

![image-20251205182624851]({{site.baseurl}}/img/in-post/article0014/image-20251205182624851.png)

名称 |	占用空间大小 |	描述
---|---|---
Space ID |	4字节 |	表空间的ID
Not Used |	4字节 |	这4个字节未被使用，可以忽略
Size |	4字节 |	当前表空间占有的页数
FREE Limit |	4字节 |	尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表
Space Flags |	4字节 |	表空间的一些占用存储空间比较小的属性
FRAG_N_USED |	4字节 |	FREE_FRAG链表中已使用的页数量
List Base Node for FREE List |	16字节 |	FREE链表的基节点
List Base Node for FREE_FRAG List |	16字节 |	FREE_FREG链表的基节点
List Base Node for FULL_FRAG List |	16字节 |	FULL_FREG链表的基节点
Next Unused Segment ID |	8字节 |	当前表空间中下一个未使用的 Segment ID（段号）
List Base Node for SEG_INODES_FULL List |	16字节 |	SEG_INODES_FULL链表的基节点
List Base Node for SEG_INODES_FREE List |	16字节 |	SEG_INODES_FREE链表的基节点

Space Flags
表空间对于一些布尔类型的属性，或者只需要寥寥几个比特位搞定的属性都放在了这个Space Flags中存储，虽然它只有4个字节，32个比特位大小，却存储了好多表空间的属性，详细情况如下表：

| 标志名称      | 占用的空间（单位：bit） | 描述                                     |
| ------------- | ----------------------- | ---------------------------------------- |
| POST_ANTELOPE | 1                       | 表示文件格式是否大于ANTELOPE             |
| ZIP_SSIZE     | 4                       | 表示压缩页的大小                         |
| ATOMIC_BLOBS  | 1                       | 表示是否自动把值非常长的字段放到BLOB页里 |
| PAGE_SSIZE    | 4                       | 页大小                                   |
| DATA_DIR      | 1                       | 表示表空间是否是从默认的数据目录中获取的 |
| SHARED        | 1                       | 是否为共享表空间                         |
| TEMPORARY     | 1                       | 是否为临时表空间                         |
| ENCRYPTION    | 1                       | 表空间是否加密                           |
| UNUSED        | 18                      | 没有使用到的比特位                       |


##### XDES Entry部分
一个XDES Entry结构的大小是40字节，但是一个页的大小有限，只能存放有限个XDES Entry结构，所以我们才把256个区划分成一组，在每组的第一个页中存放256个XDES Entry结构。

因为每个区对应的XDES Entry结构的地址是固定的，所以我们访问这些结构就so easy啦。

#### XDES类型页

一个XDES Entry结构的大小是40字节，但是一个页的大小有限，只能存放有限个XDES Entry结构，所以我们才把256个区划分成一组，在每组的第一个页中存放256个XDES Entry结构。

![image-20251205171951862]({{site.baseurl}}/img/in-post/article0014/image-20251205171951862.png)

与FSP_HDR类型的页对比，除了少了File Space Header部分之外，其余的部分是一样的。

#### IBUF_BITMAP类型页

对比前面介绍表空间的图，每个分组的第二个页的类型都是IBUF_BITMAP，这种类型的页里边记录了一些有关Change Buffer的信息。

#### INODE类型页

第一个分组的第三个页的类型是INODE。每个索引定义了两个段，而且为某些特殊功能定义了些特殊的段。

每个段对应一个INODE Entry结构，这个结构中记录了关于这个段的相关属性。

![image-20251205173718318]({{site.baseurl}}/img/in-post/article0014/image-20251205173718318.png)

| 名称                          | 中文名       | 占用空间大小 | 简单描述                               |
| ----------------------------- | ------------ | ------------ | -------------------------------------- |
| List Node for INODE Page List | 通用链表节点 | 12字节       | 存储上一个INODE页和下一个INODE页的指针 |
| INODE Entry                   | 段描述信息   | 16128字节    |                                        |

每个INODE Entry结构占用192字节，一个页里可以存储85个这样的结构。
**因为一个表空间中可能存在超过85个段，所以需要通过List Node for INODE Page List串联多个INODE类型的页**。

为了方便管理这些INODE类型的页，InnoDB设计两个不同的链表（入口节点在FSP_HDR类型页File Space Header部分固定）：
- SEG_INODES_FULL链表：该链表中的INODE类型的页中已经没有空闲空间来存储额外的INODE Entry结构了。
- SEG_INODES_FREE链表：该链表中的INODE类型的页中还有空闲空间来存储额外的INODE Entry结构了。

### Segment Header 结构的运用

一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个INODE Entry结构。

在INDEX类型的页中的Page Header部分：

Page Header部分（为突出重点，省略了好多属性）
| 名称              | 占用空间大小 | 描述                                           |
| ----------------- | ------------ | ---------------------------------------------- |
| PAGE_BTR_SEG_LEAF | 10字节       | B+树叶子段的头部信息，仅在B+树的**根页定义**   |
| PAGE_BTR_SEG_TOP  | 10字节       | B+树非叶子段的头部信息，仅在B+树的**根页定义** |

其中的PAGE_BTR_SEG_LEAF和PAGE_BTR_SEG_TOP都占用10个字节，它们其实对应一个叫Segment Header的结构，该结构图示如下：

![image-20251205173656875]({{site.baseurl}}/img/in-post/article0014/image-20251205173656875.png)

各个部分的具体释义如下：

| 名称                           | 占用字节数 | 描述                            |
| ------------------------------ | ---------- | ------------------------------- |
| Space ID of the INODE Entry    | 4          | INODE Entry结构所在的表空间ID   |
| Page Number of the INODE Entry | 4          | INODE Entry结构所在的页页号     |
| Byte Offset of the INODE Entry | 2          | INODE Entry结构在该页中的偏移量 |

因为一个索引只对应两个段，所以只需要在**索引的根页**中记录这两个结构即可。

## 系统表空间

系统表空间的结构和独立表空间基本类似，整个MySQL进程只有一个系统表空间，会额外记录一些有关整个系统信息的页，所以会比独立表空间多出一些记录这些信息的页。它的表空间 ID（Space ID）是0。

### 系统表空间的整体结构

![image-20251205174202554]({{site.baseurl}}/img/in-post/article0014/image-20251205174202554.png)

系统表空间和独立表空间的前三个页（页号分别为0、1、2，类型分别是FSP_HDR、IBUF_BITMAP、INODE）的类型是一致的，只是页号为3～7的页是系统表空间特有的:

| 页号 | 页类型                      | 英文描述           | 描述                    |
| ---- | --------------------------- | ------------------ | ----------------------- |
| 3    | SYS	Insert Buffer Header | 存储Insert         | Buffer的头部信息        |
| 4    | INDEX                       | Insert Buffer Root | 存储Insert Buffer的根页 |
| 5    | TRX_SYS                     | Transction System  | 事务系统的相关信息      |
| 6    | SYS	First                | Rollback Segment   | 第一个回滚段的页        |
| 7    | SYS	Data                 | Dictionary Header  | 数据字典头部信息        |

除了这几个记录系统属性的页之外，系统表空间的extent 1和extent 2这两个区，也就是页号从64~191这128个页被称为Doublewrite buffer，也就是双写缓冲区。

### InnoDB数据字典

InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录元数据：

| 表名             | 描述                                                       |
| ---------------- | ---------------------------------------------------------- |
| SYS_TABLES       | 整个InnoDB存储引擎中所有的表的信息                         |
| SYS_COLUMNS      | 整个InnoDB存储引擎中所有的列的信息                         |
| SYS_INDEXES      | 整个InnoDB存储引擎中所有的索引的信息                       |
| SYS_FIELDS       | 整个InnoDB存储引擎中所有的索引对应的列的信息               |
| SYS_FOREIGN      | 整个InnoDB存储引擎中所有的外键的信息                       |
| SYS_FOREIGN_COLS | 整个InnoDB存储引擎中所有的外键对应列的信息                 |
| SYS_TABLESPACES  | 整个InnoDB存储引擎中所有的表空间信息                       |
| SYS_DATAFILES    | 整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息 |
| SYS_VIRTUAL      | 整个InnoDB存储引擎中所有的虚拟生成列的信息                 |

这些系统表也被称为数据字典，它们都是以B+树的形式保存在系统表空间的某些页中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS这四个表尤其重要，称之为基本系统表（basic system tables）：

#### SYS_TABLES表
| 列名    | 描述                                             |
| ------- | ------------------------------------------------ |
| NAME    | 表的名称                                         |
| ID      | InnoDB存储引擎中每个表都有一个唯一的ID           |
| N_COLS  | 该表拥有列的个数                                 |
| TYPE    | 表的类型，记录了一些文件格式、行格式、压缩等信息 |
| MIX_LEN | 表的一些额外的属性                               |
| SPACE   | 该表所属表空间的ID                               |

这个SYS_TABLES表有两个索引：
- 以NAME列为主键的聚簇索引
- 以ID列建立的二级索引

#### SYS_COLUMNS表
| 列名     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| TABLE_ID | 该列所属表对应的ID                                           |
| POS      | 该列在表中是第几列                                           |
| NAME     | 该列的名称                                                   |
| MTYPE    | main data type，主数据类型，如INT、VARCHAR、DOUBLE之类       |
| PRTYPE   | precise type，精确数据类型，修饰主数据类型，如是否允许NULL值，是否允许负数 |
| LEN      | 该列最多占用存储空间的字节数                                 |

这个SYS_COLUMNS表只有一个聚集索引：
- (TABLE_ID, POS)列为主键的聚簇索引

#### SYS_INDEXES表

| 列名            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| TABLE_ID        | 该索引所属表对应的ID                                         |
| ID              | InnoDB存储引擎中每个索引都有一个唯一的ID                     |
| NAME            | 该索引的名称                                                 |
| N_FIELDS        | 该索引包含列的个数                                           |
| TYPE            | 该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型 |
| SPACE           | **该索引根页所在的表空间ID**                                 |
| PAGE_NO         | **该索引根页所在的页号**                                     |
| MERGE_THRESHOLD | 如果页中的记录被删除到某个比例，就把该页和相邻页合并，这个值就是这个比例 |

这个SYS_INEXES表只有一个聚集索引：
- (TABLE_ID, ID)列为主键的聚簇索引


**通过  SYS_INDEXES表中的 SPACE 和PAGE_NO 可以找到该索引的跟页面，也就可以找到该索引的两个段的INODE Entry节点。**

#### SYS_FIELDS表
| 列名     | 描述                         |
| -------- | ---------------------------- |
| INDEX_ID | 该索引列所属的索引的ID       |
| POS      | 该索引列在某个索引中是第几列 |
| COL_NAME | 该索引列的名称               |

这个SYS_INEXES表只有一个聚集索引：
- (INDEX_ID, POS)列为主键的聚簇索引

#### Data Dictionary Header页

InnoDB的设计一个固定的页来记录这4个表的聚簇索引和二级索引对应的B+树位置，这个页就是页号为7的页，类型为SYS，记录了Data Dictionary Header，也就是数据字典的头部信息。

![image-20251205175811094]({{site.baseurl}}/img/in-post/article0014/image-20251205175811094.png)

- Max Row ID：插入记录的row_id列的值就是Max Row ID对应的值，然后再把Max Row ID对应的值加1，也就是说这个Max Row ID是全局共享的。
- Max Table ID：每次新建一个表时，该表的ID = Max Table ID++。
- Max Index ID：每次新建一个索引时，该索引的ID = Max Index ID++
- Max Space ID：每次新建一个表空间时，该表空间的ID = Max Space ID++。
- Root of SYS_TABLES clust index：本字段代表SYS_TABLES表**聚簇索引**的根页的页号。
- Root of SYS_TABLE_IDS sec index：本字段代表SYS_TABLES表为**ID列建立的二级索引**的根页的页号。
- Root of SYS_COLUMNS clust index：本字段代表SYS_COLUMNS表聚簇索引的根页的页号。
- Root of SYS_INDEXES clust index本字段代表SYS_INDEXES表聚簇索引的根页的页号。
- Root of SYS_FIELDS clust index：本字段代表SYS_FIELDS表聚簇索引的根页的页号。

## 表空间小结

表空间被化为许多连续的区，每个区默认63个页（16KB）即1MB，每 256个区划分为一组，每组最开始的几个页面的类型固定。其中每组第一个页面都存储着该组256个区对应的 XDES Entry。

- XDES Entry 表示 区结构
- INODE Entry 表示 段结构

通过**系统表空间**第7号页面的 Root of SYS_INDEXES clust 找到 SYS_INDEXES表。

通过SYS_INDEXES表中的 SPACE 和PAGE_NO 可以找到该索引的跟页面，也就可以找到该索引的两个段的INODE Entry节点。

通过INODE Entry节点找到**段中的 碎片化的页和三条 XDES Entry链表**



一个表空间可能有多个索引，一个索引有两个段，一个段中有三个XDES Entry链表。

一个表空间有三个XDES Entry链表（碎片区），两条INODE类型的页链表（仅用于快速找到空闲的INODE页来存储INODE Entry数据，查找数据是通过SYS_INDEXES表查找根节点在的）